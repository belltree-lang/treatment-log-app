# 銀行引落シートの未回収/合算フラグの設計メモ（Issue #807）

## 前提と目的
- IssueC のスコープは「設計ドキュメントのみ」。本メモは今後 AE / AF を prepared / billingJson に正しく反映するための設計案をまとめる。
- 実装やテストコードの追加は行わず、合意済みの業務定義とデータ流通の方針を明文化する。

## AE / AF の業務定義
- **AE = 未回収**
  - 口座振替が成立しない（月内引落不可、残高不足、引落未実施など）。
  - AE=ON の月は領収書を発行してはいけない。
- **AF = 合算**
  - 当月の請求金額を翌月以降に合算して請求する予定であることを示す。
  - AF=ON の月単体では請求を立てず、後続月に合算する。
- **領収書発行条件**
  - 領収書を発行できるのは **AE=OFF かつ AF=OFF** の場合のみ。
  - どちらか一方でも ON の場合は「領収書を発行しない」が正となる。

## データの持ち方（prepared / billingJson への反映方針）
- **単位の候補**
  - 患者単位: 患者 ID をキーにフラグをぶら下げる。月横断の状態管理には不向き。
  - 月単位: 請求月をキーに AE/AF を保持。月ごとの領収可否判定を直接行える。
  - 行単位: 銀行引落シートの行（=患者×月）をキーに保持。最も情報量が多いが payload が肥大化しがち。
- **推奨**
  - prepared / billingJson では「**月単位 + 患者キーの組み合わせ**」で保持する。例: `bankFlagsByPatient[monthKey][patientId] = { ae, af }`。
  - 理由: 月別の請求・領収判定で AE/AF が必要となるため、月キーを第一キーに据えることで aggregateUntilMonth との付き合わせが容易になる。

## 既存の receiptStatus / aggregateUntilMonth との整合
- **選択肢**
  1. 既存フィールドを維持しつつ AE/AF を追加: backward compatibility は高いが、判定根拠が二重になる。
  2. AE/AF を正とし、receiptStatus / aggregateUntilMonth は派生値として上書き・再計算する。
- **推奨案**
  - **AE/AF を唯一の正とする**。prepared 生成時に AE/AF から receiptStatus / aggregateUntilMonth を算出して保存する。
  - 理由: 銀行引落シートが唯一の一次情報源であり、重複状態を持つと食い違いが発生しやすいため。
  - 過去データ移行が必要な場合は、AE/AF が無い月だけ既存値を尊重するフォールバックを検討する。

## 列位置ではなくヘッダ名で解決する理由
- 銀行引落シートは運用上、列の挿入・並べ替えが起こり得るため、列文字（例: AE/AF 固定列）を前提にすると壊れやすい。
- ヘッダ名「未回収チェック」「合算」をキーに解決することで、列位置が変わってもロジックが耐性を持つ。
- 列追加やフィルタビューの影響を受けにくく、シートテンプレート変更時のリスクを下げられる。

## 実装時の受入条件（テスト観点）
- **ヘッダ解決**: 列位置が変わっても「未回収チェック」「合算」を検出できること。列欠落時はデフォルト false（特に AF 欠落時）。
- **データ解釈**: 0/1, TRUE/FALSE, '✓' などを正規化し、`{ ae: boolean, af: boolean }` を得ること。
- **マッピング**: 患者 ID 列がなくても氏名+カナで prepared 患者情報と付き合わせられること。
- **パフォーマンス**: 月次シート全件を読み取っても許容時間内（Apps Script 実行時間制限内）に収まること。
- **互換性**: AE/AF が無い月は既存の receiptStatus / aggregateUntilMonth 判定を壊さないこと。
- **エンドツーエンド**: prepared / billingJson に AE/AF が載り、領収書発行可否・合算計算が期待通りに反映されること。
