<script>
const billingState = {
  loading: false,
  result: null,
  prepared: null,
  statusMessage: '',
  errorMessage: '',
  edits: {},
  patientInfoEdits: {},
  billingOverrideEdits: {},
  previewTotals: {},
  editing: null,
  invoiceMode: 'bulk',
  invoicePatientIdsInput: '',
  receiptStatus: '',
  aggregateUntilMonth: '',
  receiptSaving: false,
  sort: { field: null, direction: 'asc' }
};

const bankFlowState = {
  loading: false,
  status: '',
  error: '',
  aggregation: null,
  sheet: null,
  finalized: null,
  unpaid: null,
  targetMonth: ''
};

const simpleBankState = {
  loading: false,
  status: '',
  error: '',
  result: null,
  targetMonth: ''
};

const BILLING_BURDEN_OPTIONS = [
  { value: 1, label: '1割' },
  { value: 2, label: '2割' },
  { value: 3, label: '3割' },
  { value: '自費', label: '自費' }
];
const BILLING_PAYER_OPTIONS = ['保険', '自費'];
const BILLING_TREATMENT_PRICE = 4070;
const BILLING_ELECTRO_PRICE = 100;
const BILLING_UNIT_PRICE = BILLING_TREATMENT_PRICE + BILLING_ELECTRO_PRICE;
const BILLING_TRANSPORT_UNIT_PRICE_FALLBACK = 33;
const BILLING_TRANSPORT_UNIT_PRICE = (typeof globalThis !== 'undefined' && typeof globalThis.BILLING_TRANSPORT_UNIT_PRICE === 'number')
  ? globalThis.BILLING_TRANSPORT_UNIT_PRICE
  : BILLING_TRANSPORT_UNIT_PRICE_FALLBACK;
const BILLING_PATIENT_INFO_FIELDS = ['medicalAssistance', 'burdenRate', 'payerType', 'responsible', 'bankInfo', 'isNew'];
const BILLING_BILLING_OVERRIDES_FIELDS = ['unitPrice', 'transportAmount', 'carryOverAmount', 'visitCount', 'selfPayAmount'];
const BILLING_OVERRIDE_BADGE_FIELDS = ['unitPrice', 'transportAmount', 'carryOverAmount', 'visitCount', 'selfPayAmount', 'burdenRate'];

function qs(id) {
  return document.getElementById(id);
}

function escapeHtml(text) {
  return String(text || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function getDefaultMonth() {
  const today = new Date();
  const prevMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1);
  const y = prevMonth.getFullYear();
  const m = String(prevMonth.getMonth() + 1).padStart(2, '0');
  return y + '-' + m;
}

function updateBillingControls() {
  const monthInput = qs('billingMonth');
  const aggregateBtn = qs('billingAggregateBtn');
  const pdfBtn = qs('billingPdfBtn');
  const saveBtn = qs('billingSaveBtn');
  const loading = billingState.loading;
  const prepared = !!(billingState.prepared && billingState.prepared.billingMonth);

  if (monthInput) {
    monthInput.disabled = loading;
  }
  if (aggregateBtn) {
    aggregateBtn.disabled = loading;
    aggregateBtn.setAttribute('aria-busy', loading ? 'true' : 'false');
  }
  if (pdfBtn) {
    const disabled = loading || !prepared;
    pdfBtn.disabled = disabled;
    pdfBtn.setAttribute('aria-busy', loading ? 'true' : 'false');
    pdfBtn.title = disabled && !prepared ? '先に「請求データを集計」を実行してください' : '';
  }
  if (saveBtn) {
    const disabled = loading || !prepared;
    saveBtn.disabled = disabled;
    saveBtn.setAttribute('aria-busy', loading ? 'true' : 'false');
    saveBtn.title = disabled && !prepared ? '先に「請求データを集計」を実行してください' : '';
  }
  updateInvoiceModeControls();
  renderReceiptControls();
}

function getBankTargetMonth() {
  const input = qs('bankWithdrawalMonth');
  if (input && input.value) return normalizeYm(input.value);
  const billingInput = qs('billingMonth');
  return normalizeYm(billingInput && billingInput.value ? billingInput.value : '');
}

function getSimpleBankMonth() {
  const input = qs('bankWithdrawalMonth');
  return input && input.value ? normalizeYm(input.value) : '';
}

const BILLING_FINALIZED_ALERT_MESSAGE = 'この請求は確定済みのため操作できません';

function shouldBlockFinalizedBillingOperation() {
  if (!hasFinalizedBillingRows()) return false;
  alert(BILLING_FINALIZED_ALERT_MESSAGE);
  return true;
}

function hasFinalizedBillingRows() {
  const rows = billingState.prepared && billingState.prepared.billingJson;
  return Array.isArray(rows) && rows.some(isBillingRowFinalized);
}

function isReceiptEditingLocked() {
  return hasFinalizedBillingRows();
}

function updateInvoiceModeControls() {
  const loading = billingState.loading;
  const prepared = !!(billingState.prepared && billingState.prepared.billingMonth);
  const mode = getInvoiceMode();
  const patientInput = qs('invoicePatientIds');
  const note = qs('invoicePatientIdsNote');
  const isPartial = mode === 'partial';

  const radioButtons = Array.from(document.querySelectorAll('input[name="invoiceMode"]'));
  radioButtons.forEach(btn => {
    btn.disabled = loading;
    if (btn.value === mode) {
      btn.checked = true;
    }
  });

  if (patientInput) {
    patientInput.disabled = loading || !prepared || !isPartial;
    if (!isPartial && !loading) {
      patientInput.value = billingState.invoicePatientIdsInput || patientInput.value;
    }
  }

  if (note) {
    note.className = isPartial ? 'field-note warn' : 'field-note';
  }
}

function renderReceiptControls() {
  const statusSelect = qs('receiptStatus');
  const aggregateInput = qs('receiptAggregateUntil');
  const display = qs('receiptAggregateDisplay');
  const prepared = !!(billingState.prepared && billingState.prepared.billingMonth);
  const loading = billingState.loading || billingState.receiptSaving;
  const status = billingState.receiptStatus || '';
  const aggregate = billingState.aggregateUntilMonth || '';
  const locked = isReceiptEditingLocked();

  if (statusSelect) {
    statusSelect.value = status || '';
    statusSelect.disabled = !prepared || loading || locked;
    statusSelect.title = locked ? '確定済みの請求が含まれているため変更できません' : '';
  }

  if (aggregateInput) {
    aggregateInput.value = aggregate ? `${aggregate.slice(0, 4)}-${aggregate.slice(4, 6)}` : '';
    aggregateInput.disabled = !prepared || loading || status !== 'AGGREGATE' || locked;
    aggregateInput.title = locked ? '確定済みの請求が含まれているため変更できません' : '';
  }

  if (display) {
    display.textContent = aggregate ? formatYmDisplay(aggregate) : '—';
  }
}

function normalizeInvoicePatientIdsInput(text) {
  if (Array.isArray(text)) {
    return text
      .map(v => String(v || '').trim())
      .filter(Boolean)
      .filter((v, idx, arr) => arr.indexOf(v) === idx);
  }
  return String(text || '')
    .split(/[\s,、]+/)
    .map(v => v.trim())
    .filter(Boolean)
    .filter((v, idx, arr) => arr.indexOf(v) === idx);
}

function getInvoiceMode() {
  const checked = document.querySelector('input[name="invoiceMode"]:checked');
  if (checked && checked.value === 'partial') return 'partial';
  return 'bulk';
}

function getInvoicePatientIdsInput() {
  const textarea = qs('invoicePatientIds');
  return textarea && textarea.value ? textarea.value : '';
}

function handleInvoiceModeToggle(event) {
  if (event && event.target && event.target.value) {
    billingState.invoiceMode = event.target.value === 'partial' ? 'partial' : 'bulk';
  }
  updateInvoiceModeControls();
}

function handleInvoicePatientInput(event) {
  const value = event && event.target ? event.target.value : getInvoicePatientIdsInput();
  billingState.invoicePatientIdsInput = value;
}

function handleReceiptStatusChange(event) {
  if (isReceiptEditingLocked()) {
    renderReceiptControls();
    alert(BILLING_FINALIZED_ALERT_MESSAGE);
    return;
  }
  const value = event && event.target ? event.target.value : '';
  const status = String(value || '').trim().toUpperCase();
  billingState.receiptStatus = status;
  renderReceiptControls();
  persistReceiptStatus();
}

function handleReceiptAggregateChange(event) {
  if (isReceiptEditingLocked()) {
    renderReceiptControls();
    alert(BILLING_FINALIZED_ALERT_MESSAGE);
    return;
  }
  const value = event && event.target ? event.target.value : '';
  const ym = normalizeYm(value);
  billingState.aggregateUntilMonth = ym;
  renderReceiptControls();
  persistReceiptStatus();
}

function persistReceiptStatus() {
  if (isReceiptEditingLocked()) {
    renderReceiptControls();
    alert(BILLING_FINALIZED_ALERT_MESSAGE);
    return;
  }
  if (!billingState.prepared || !billingState.prepared.billingMonth) {
    alert('先に「請求データを集計」を実行してください。');
    return;
  }
  const status = billingState.receiptStatus || '';
  const aggregateUntil = status === 'AGGREGATE' ? billingState.aggregateUntilMonth : '';
  billingState.aggregateUntilMonth = aggregateUntil;
  billingState.receiptSaving = true;
  updateBillingControls();

  google.script.run
    .withSuccessHandler(function(result) {
      const normalized = normalizeBillingResultPayload(result) || billingState.prepared || null;
      billingState.result = normalized;
      billingState.prepared = normalized;
      syncReceiptStateFromPayload(normalized);
      billingState.receiptSaving = false;
      renderBillingResult();
    })
    .withFailureHandler(function(err) {
      billingState.receiptSaving = false;
      const message = err && err.message ? err.message : '領収状態の保存に失敗しました';
      setBillingError(message, err);
      renderBillingResult();
    })
    .updateBillingReceiptStatus(billingState.prepared.billingMonth, {
      receiptStatus: status,
      aggregateUntil
    });
}

function formatYmDisplay(ym) {
  if (!ym || ym.length !== 6) return '';
  return ym.slice(0, 4) + '-' + ym.slice(4);
}

function formatDateTimeDisplay(value) {
  if (!value) return '';
  const date = new Date(value);
  if (!(date instanceof Date) || isNaN(date.getTime())) return '';
  const y = date.getFullYear();
  const m = String(date.getMonth() + 1).padStart(2, '0');
  const d = String(date.getDate()).padStart(2, '0');
  const hh = String(date.getHours()).padStart(2, '0');
  const mm = String(date.getMinutes()).padStart(2, '0');
  return `${y}/${m}/${d} ${hh}:${mm}`;
}

function getBankSheetSummary() {
  if (bankFlowState.sheet && bankFlowState.sheet.sheetSummary) return bankFlowState.sheet.sheetSummary;
  if (bankFlowState.finalized && bankFlowState.finalized.sheetSummary) return bankFlowState.finalized.sheetSummary;
  if (bankFlowState.aggregation && bankFlowState.aggregation.sheetSummary) return bankFlowState.aggregation.sheetSummary;
  return null;
}

function updateBankControls() {
  const monthInput = qs('bankWithdrawalMonth');
  const aggregateBtn = qs('bankAggregateBtn');
  const sheetBtn = qs('bankSheetBtn');
  const finalizeBtn = qs('bankFinalizeBtn');
  const unpaidBtn = qs('bankUnpaidBtn');
  const loading = bankFlowState.loading;
  const selectedMonth = getBankTargetMonth();
  const sheetSummary = getBankSheetSummary();
  const hasMonth = !!selectedMonth;
  const hasAggregation = bankFlowState.aggregation && bankFlowState.aggregation.billingMonth === selectedMonth;
  const hasSheet = sheetSummary && sheetSummary.exists && sheetSummary.billingMonth === selectedMonth;

  if (monthInput) monthInput.disabled = loading;
  if (aggregateBtn) {
    const disabled = loading || !hasMonth;
    aggregateBtn.disabled = disabled;
    aggregateBtn.setAttribute('aria-busy', loading ? 'true' : 'false');
    aggregateBtn.title = disabled && !hasMonth ? '対象月を入力してください' : '';
  }
  if (sheetBtn) {
    const disabled = loading || !hasMonth || !hasAggregation || hasSheet;
    sheetBtn.disabled = disabled;
    sheetBtn.setAttribute('aria-busy', loading ? 'true' : 'false');
    if (!hasMonth) {
      sheetBtn.title = '対象月を入力してください';
    } else if (!hasAggregation) {
      sheetBtn.title = '先に「請求データ集計」を実行してください';
    } else if (hasSheet) {
      sheetBtn.title = 'この月の銀行引落シートは生成済みです';
    } else {
      sheetBtn.title = '';
    }
  }
  if (unpaidBtn) {
    const disabled = loading || !hasMonth || !hasSheet;
    unpaidBtn.disabled = disabled;
    unpaidBtn.setAttribute('aria-busy', loading ? 'true' : 'false');
    unpaidBtn.title = disabled && !hasSheet ? '銀行引落シート生成後に実行できます' : '';
  }
  if (finalizeBtn) {
    const disabled = loading || !hasMonth || !hasAggregation;
    finalizeBtn.disabled = disabled;
    finalizeBtn.setAttribute('aria-busy', loading ? 'true' : 'false');
    finalizeBtn.title = disabled && !hasAggregation ? '先に「請求データ集計」を実行してください' : '';
  }
  renderBankFlowSummary();
}

function renderBankFlowDetail() {
  const statusEl = qs('bankFlowStatus');
  const errorEl = qs('bankFlowError');
  const detailEl = qs('bankFlowDetail');

  if (statusEl) {
    statusEl.textContent = bankFlowState.status || '操作待ちです。';
  }

  if (errorEl) {
    if (bankFlowState.error) {
      errorEl.textContent = bankFlowState.error;
      errorEl.style.display = 'block';
    } else {
      errorEl.textContent = '';
      errorEl.style.display = 'none';
    }
  }

  if (detailEl) {
    const lines = [];
    if (bankFlowState.aggregation) {
      const agg = bankFlowState.aggregation;
      const countText = agg.billingCount != null ? `${agg.billingCount}件` : '';
      lines.push(`請求データ集計済み: ${agg.billingMonth || ''} ${countText}`.trim());
    }
    if (bankFlowState.sheet && bankFlowState.sheet.sheetSummary) {
      const summary = bankFlowState.sheet.sheetSummary;
      const updatedText = bankFlowState.sheet.bankSheet && bankFlowState.sheet.bankSheet.updated != null
        ? `（更新 ${bankFlowState.sheet.bankSheet.updated} 行）`
        : '';
      lines.push(`銀行引落シート: ${summary.rows} 行 ${updatedText}`.trim());
      if (summary.unpaidChecked) {
        lines.push(`未回収チェック: ${summary.unpaidChecked} 件`);
      }
    }
    if (bankFlowState.finalized) {
      const finalized = bankFlowState.finalized;
      const summary = finalized.sheetSummary || {};
      lines.push(`確定済み: ${finalized.billingMonth || ''}（行数 ${summary.rows || 0}）`);
    }
    if (bankFlowState.unpaid) {
      const unpaid = bankFlowState.unpaid;
      const addedText = unpaid.added != null ? `追加 ${unpaid.added} 件` : '';
      const skippedText = unpaid.skipped ? ` / スキップ ${unpaid.skipped}` : '';
      const checkedText = unpaid.checkedRows != null ? `（チェック済み ${unpaid.checkedRows} 行）` : '';
      lines.push(`未回収反映: ${addedText}${skippedText}${checkedText}`.trim());
    }

    if (lines.length) {
      detailEl.innerHTML = '<ul><li>' + lines.map(escapeHtml).join('</li><li>') + '</li></ul>';
      detailEl.style.display = 'block';
    } else {
      detailEl.textContent = 'まだ操作が実行されていません。';
      detailEl.style.display = 'block';
    }
  }

  renderBankFlowSummary();
}

function setBankLoading(flag, message) {
  bankFlowState.loading = !!flag;
  bankFlowState.status = flag ? (message || '') : bankFlowState.status;
  if (flag) bankFlowState.error = '';
  updateBankControls();
  renderBankFlowDetail();
}

function setBankError(message, err) {
  const detail = err && err.message ? err.message : (err != null ? String(err) : '');
  bankFlowState.error = message ? `${message}: ${detail || ''}` : (detail || '不明なエラー');
  bankFlowState.loading = false;
  renderBankFlowDetail();
}

function normalizeYm(raw) {
  if (!raw) return '';
  const cleaned = String(raw).replace(/[^0-9]/g, '');
  if (cleaned.length === 6) return cleaned;
  if (cleaned.length === 4) return cleaned + '01';
  return '';
}

function renderBankFlowSummary() {
  const ym = bankFlowState.targetMonth || getBankTargetMonth();
  const displayYm = ym ? formatYmDisplay(ym) : '未選択';
  const summary = getBankSheetSummary();
  const currentMonthEl = qs('bankCurrentMonth');
  const sheetStatusEl = qs('bankSheetStatus');
  const unpaidCountEl = qs('bankUnpaidCount');

  if (currentMonthEl) {
    currentMonthEl.textContent = displayYm || '未選択';
  }
  if (sheetStatusEl) {
    if (summary && summary.exists) {
      sheetStatusEl.textContent = `${formatYmDisplay(summary.billingMonth)} 生成済み（${summary.rows || 0}行）`;
    } else {
      sheetStatusEl.textContent = '未生成';
    }
  }
  if (unpaidCountEl) {
    const count = summary && typeof summary.unpaidChecked === 'number' ? summary.unpaidChecked : 0;
    unpaidCountEl.textContent = `${count}件`;
  }
}

function updateSimpleBankControls() {
  const monthInput = qs('bankWithdrawalMonth');
  const generateBtn = qs('simpleBankGenerateBtn');
  const loading = simpleBankState.loading;
  const hasMonth = !!(simpleBankState.targetMonth || getSimpleBankMonth());

  if (monthInput) monthInput.disabled = loading;
  if (generateBtn) {
    generateBtn.disabled = loading || !hasMonth;
    generateBtn.setAttribute('aria-busy', loading ? 'true' : 'false');
    generateBtn.title = hasMonth ? '' : '対象月を入力してください';
  }
}

function renderSimpleBankSummary() {
  const ym = simpleBankState.targetMonth || getSimpleBankMonth();
  const displayYm = ym ? formatYmDisplay(ym) : '未選択';
  const summary = simpleBankState.result;
  const currentMonthEl = qs('bankCurrentMonth');
  const sheetStatusEl = qs('bankSheetStatus');
  const missingEl = qs('bankUnpaidCount');

  if (currentMonthEl) {
    currentMonthEl.textContent = displayYm || '未選択';
  }
  if (sheetStatusEl) {
    if (summary && summary.sheetName) {
      sheetStatusEl.textContent = `${summary.sheetName}（${summary.rows || 0}行）`;
    } else {
      sheetStatusEl.textContent = '未生成';
    }
  }
  if (missingEl) {
    const missingCount = summary && Array.isArray(summary.missingAccounts)
      ? summary.missingAccounts.length
      : 0;
    missingEl.textContent = `${missingCount}件`;
  }
}

function renderSimpleBankDetail() {
  const statusEl = qs('bankFlowStatus');
  const errorEl = qs('bankFlowError');
  const detailEl = qs('bankFlowDetail');
  const summary = simpleBankState.result;

  if (statusEl) {
    statusEl.textContent = simpleBankState.status || 'まだ実行していません。';
  }

  if (errorEl) {
    if (simpleBankState.error) {
      errorEl.textContent = simpleBankState.error;
      errorEl.style.display = 'block';
    } else {
      errorEl.textContent = '';
      errorEl.style.display = 'none';
    }
  }

  if (detailEl) {
    const lines = [];
    if (summary && summary.sheetName) {
      lines.push(`シート名: ${summary.sheetName}`);
      lines.push(`行数: ${summary.rows || 0} 行`);
      lines.push(`金額転記: ${summary.filled || 0} 件`);
    }
    if (summary && Array.isArray(summary.missingAccounts) && summary.missingAccounts.length) {
      lines.push('口座情報なし: ' + summary.missingAccounts.join(', '));
    }
    if (lines.length) {
      detailEl.innerHTML = '<ul><li>' + lines.map(escapeHtml).join('</li><li>') + '</li></ul>';
      detailEl.style.display = 'block';
    } else {
      detailEl.textContent = '銀行処理の結果がここに表示されます。';
      detailEl.style.display = 'block';
    }
  }

  renderSimpleBankSummary();
}

function setSimpleBankLoading(flag, message) {
  simpleBankState.loading = !!flag;
  simpleBankState.status = flag ? (message || '') : simpleBankState.status;
  if (flag) simpleBankState.error = '';
  updateSimpleBankControls();
  renderSimpleBankDetail();
}

function setSimpleBankError(message, err) {
  const detail = err && err.message ? err.message : (err != null ? String(err) : '');
  simpleBankState.error = message ? `${message}: ${detail || ''}` : (detail || '不明なエラー');
  simpleBankState.loading = false;
  renderSimpleBankDetail();
}

function onSimpleBankCompleted(result) {
  simpleBankState.loading = false;
  simpleBankState.result = result || null;
  const missing = result && Array.isArray(result.missingAccounts) ? result.missingAccounts : [];
  const filledText = result ? `${result.filled || 0}/${result.rows || 0}件` : '';
  simpleBankState.status = result ? `銀行シートを作成しました（${filledText}）` : '銀行シートを作成しました。';
  simpleBankState.error = missing.length ? `口座情報が見つからない患者: ${missing.join(', ')}` : '';
  renderSimpleBankDetail();
  updateSimpleBankControls();
}

function handleSimpleBankSheetGeneration() {
  const ym = getSimpleBankMonth();
  if (!ym) {
    alert('対象月を入力してください (YYYY-MM)');
    return;
  }
  simpleBankState.targetMonth = ym;
  setSimpleBankLoading(true, '銀行シート作成中…');
  google.script.run
    .withSuccessHandler(function(result) {
      onSimpleBankCompleted(result);
    })
    .withFailureHandler(function(err) {
      setSimpleBankError('銀行シート生成に失敗しました', err);
    })
    .generateSimpleBankSheet(ym);
}

function logBillingState(stage, extra) {
  let snapshot = billingState;
  try {
    snapshot = JSON.parse(JSON.stringify(billingState));
    console.log('[billingState][' + stage + ']', snapshot, extra || '');
  } catch (err) {
    console.log('[billingState][' + stage + '] (serialization failed)', err, billingState, extra || '');
  }

  try {
    const debugEl = qs('billingDebug');
    if (debugEl) {
      const resultLength = snapshot && snapshot.result && Array.isArray(snapshot.result.billingJson)
        ? snapshot.result.billingJson.length
        : 0;
      const preparedLength = snapshot && snapshot.prepared && Array.isArray(snapshot.prepared.billingJson)
        ? snapshot.prepared.billingJson.length
        : 0;
      const extraText = extra ? JSON.stringify(extra) : '';
      const lines = [
        `[${new Date().toISOString()}] stage: ${stage}`,
        `  result rows: ${resultLength}`,
        `  prepared rows: ${preparedLength}`,
        `  loading: ${!!snapshot.loading}`,
        `  status: ${snapshot.statusMessage || ''}`,
        `  extra: ${extraText}`
      ];
      debugEl.textContent += (debugEl.textContent ? '\n' : '') + lines.join('\n') + '\n';
    }
  } catch (err) {
    console.log('[billingState][' + stage + '] (ui log failed)', err);
  }
}

function setBillingLoading(flag, message) {
  billingState.loading = !!flag;
  billingState.statusMessage = flag ? (message || '生成中…') : '';
  if (flag) {
    billingState.errorMessage = '';
  }
  logBillingState('setBillingLoading', { message: billingState.statusMessage });
  renderBillingResult();
}

function setBillingError(message, err) {
  const detail = err && err.message ? err.message : (err != null ? String(err) : '');
  const combined = detail && message ? `${message}: ${detail}` : (message || detail || '不明なエラー');
  billingState.errorMessage = combined;
  logBillingState('billingError', { message: combined });
  renderBillingResult();
}

function normalizeEditNumber(value) {
  return normalizeMoneyNumber(value);
}

function normalizeMoneyNumber(value) {
  if (typeof value === 'number') {
    return Number.isFinite(value) ? value : 0;
  }
  const text = String(value || '')
    .normalize('NFKC')
    .replace(/[，,]/g, '')
    .trim();
  if (!text) return 0;
  const num = Number(text);
  return Number.isFinite(num) ? num : 0;
}

function normalizeVisitCount(value) {
  if (typeof value === 'number') {
    return Number.isFinite(value) && value > 0 ? value : 0;
  }
  const normalized = String(value || '')
    .normalize('NFKC')
    .replace(/[，,]/g, '')
    .trim();
  const num = Number(normalized);
  return Number.isFinite(num) && num > 0 ? num : 0;
}

function normalizeBurdenRateInt(value) {
  if (value == null || value === '') return 0;
  if (String(value).trim() === '自費') return '自費';
  const num = Number(value);
  if (Number.isFinite(num)) {
    if (num > 0 && num < 1) return Math.round(num * 10);
    if (num >= 1 && num < 10) return Math.round(num);
    if (num >= 10 && num <= 100) return Math.round(num / 10);
  }

  const normalized = String(value).normalize('NFKC').replace(/\s+/g, '').replace('％', '%');
  const withoutUnits = normalized.replace(/割|分/g, '').replace('%', '');
  const parsed = Number(withoutUnits);
  if (!Number.isFinite(parsed)) return 0;
  if (normalized.indexOf('%') >= 0) return Math.round(parsed / 10);
  if (parsed > 0 && parsed < 10) return Math.round(parsed);
  if (parsed >= 10 && parsed <= 100) return Math.round(parsed / 10);
  return 0;
}

function normalizeBurdenRateDisplay(value) {
  if (value === '自費') return '自費';
  const num = normalizeBurdenRateInt(value);
  if (!Number.isFinite(num) || num <= 0) return '';
  return num + '割';
}

function normalizeMedicalAssistanceFlag(value) {
  if (value === 1 || value === '1' || value === true) return 1;
  return 0;
}

function getBillingBaseUrl() {
  return (window.APP_CONFIG && window.APP_CONFIG.baseUrl) || '';
}

function getBillingOverrideFlags() {
  const source = billingState.prepared || billingState.result || {};
  return (source && source.billingOverrideFlags) || {};
}

function shouldShowBillingOverrideBadge(field) {
  return BILLING_OVERRIDE_BADGE_FIELDS.indexOf(field) >= 0;
}

function hasBillingOverride(patientId, field) {
  if (!patientId || !shouldShowBillingOverrideBadge(field)) return false;
  const flags = getBillingOverrideFlags();
  const entry = flags && flags[patientId];
  return !!(entry && entry[field]);
}

function wrapWithOverrideBadge(content, patientId, field, alignRight) {
  if (!shouldShowBillingOverrideBadge(field) || !hasBillingOverride(patientId, field)) {
    return content;
  }
  const badge = '<span class="override-badge" title="月次編集されています">※上書き</span>';
  const klass = alignRight ? 'cell-badge right' : 'cell-badge';
  return `<div class="${klass}">${content}${badge}</div>`;
}

function getMergedBillingRows() {
  const baseRows = Array.isArray(billingState.result && billingState.result.billingJson)
    ? billingState.result.billingJson
    : [];
  return baseRows.map(row => {
    try {
      const baseRow = row && typeof row === 'object' ? row : {};
      const finalized = isBillingRowFinalized(baseRow);
      const edits = finalized ? {} : billingState.edits[baseRow.patientId] || {};
      const calculated = finalized
        ? {}
        : (billingState.previewTotals && billingState.previewTotals[baseRow.patientId]) || {};
      return Object.assign({}, baseRow, edits, calculated);
    } catch (err) {
      console.error('Failed to merge billing row', err, row);
      return null;
    }
  }).filter(Boolean);
}

function getResponsibleDisplay(item) {
  if (!item) return '';
  if (item.responsibleName) return item.responsibleName;
  if (Array.isArray(item.responsibleNames) && item.responsibleNames.length) {
    return item.responsibleNames.join('・');
  }
  return item.responsibleEmail || '';
}

function formatPaidStatus(item) {
  if (!item) return '';
  return item.paidStatus || item.bankStatus || '';
}

function normalizeReceiptStatus(status) {
  return String(status || '').trim().toUpperCase();
}

function isBillingRowFinalized(item) {
  const flag = item && item.billingFinalized;
  return flag === true || flag === 'true' || flag === 1 || flag === '1';
}

function getFinalizationDetailParts(item) {
  const timestamp = formatDateTimeDisplay(item && item.finalizedAt);
  const actor = item && item.finalizedBy ? String(item.finalizedBy).trim() : '';
  return [timestamp, actor].filter(Boolean);
}

function getFinalizationDetailText(item) {
  return getFinalizationDetailParts(item).join(' / ');
}

function renderReceiptStatusBadge(item) {
  const finalized = isBillingRowFinalized(item);
  const status = normalizeReceiptStatus(item && item.receiptStatus);
  const aggregateLabel = status === 'AGGREGATE'
    ? (item && item.aggregateUntilMonth ? formatYmDisplay(item.aggregateUntilMonth) : '')
    : '';

  if (!finalized && status !== 'AGGREGATE') return '';

  const titleLines = finalized
    ? ['この請求は合算確定です']
    : ['この請求は合算請求として処理予定です'];

  const subText = (() => {
    if (finalized) {
      const detail = getFinalizationDetailText(item);
      if (detail) {
        titleLines.push(detail);
        return `<span class="receipt-badge-sub">${escapeHtml(detail)}</span>`;
      }
      return '';
    }
    if (aggregateLabel) {
      titleLines.push(`${aggregateLabel}までの合算を予定`);
      return `<span class="receipt-badge-sub">〜${escapeHtml(aggregateLabel)}合算</span>`;
    }
    return '';
  })();

  const badgeClass = finalized ? 'receipt-badge finalized' : 'receipt-badge aggregate';
  const label = finalized ? '合算確定' : '合算予定';
  return ` <span class="receipt-badge-group"><span class="${badgeClass}" title="${escapeHtml(titleLines.join(' / '))}">${label}</span>${subText}</span>`;
}

function maskAccountNumber(value) {
  const digits = (value || '').replace(/\D/g, '');
  if (!digits) return '';
  const suffix = digits.slice(-4);
  return suffix ? `***${suffix}` : '';
}

function formatBankInfo(item) {
  if (!item) return '';
  const bankCode = item.bankCode || '';
  const branchCode = item.branchCode || '';
  const accountNumber = item.accountNumber || '';
  const codes = [bankCode, branchCode].filter(Boolean).join('-');
  const account = maskAccountNumber(accountNumber);
  return [codes, account ? `口:${account}` : ''].filter(Boolean).join(' / ');
}

function formatNewFlag(item) {
  if (!item || !item.isNew) return '';
  return '<span class="badge">新規</span>';
}

function resolvePatientIdSortValue(value) {
  const num = Number(value);
  if (Number.isFinite(num)) return num;
  const trimmed = String(value || '').trim();
  if (!trimmed) return 0;
  const fallback = Number(trimmed.replace(/[^0-9]/g, ''));
  return Number.isFinite(fallback) ? fallback : 0;
}

function resolveBurdenSortValue(value) {
  if (value === '自費') return 99;
  const num = Number(value);
  if (Number.isFinite(num)) return num;
  return 0;
}

function resolveBillingSortValue(row, field) {
  switch (field) {
    case 'nameKanji':
      return row.nameKanji || '';
    case 'burdenRate':
      return resolveBurdenSortValue(row.burdenRate);
    case 'unitPrice':
      return Number(row.unitPrice) || 0;
    case 'visitCount':
      return Number(row.visitCount) || 0;
    case 'treatmentAmount':
      return Number(row.treatmentAmount) || 0;
    case 'transportAmount':
      return Number(row.transportAmount) || 0;
    case 'carryOverAmount':
      return Number(row.carryOverAmount) || 0;
    case 'grandTotal':
      return Number(row.grandTotal) || 0;
    case 'responsible':
      return getResponsibleDisplay(row);
    case 'patientId':
      return resolvePatientIdSortValue(row.patientId);
    default:
      return null;
  }
}

function sortBillingRows(rows) {
  const sort = billingState.sort || {};
  if (!sort.field || !Array.isArray(rows)) return rows || [];
  const dir = sort.direction === 'desc' ? -1 : 1;
  return rows.slice().sort((a, b) => {
    const va = resolveBillingSortValue(a, sort.field);
    const vb = resolveBillingSortValue(b, sort.field);
    if (va == null && vb == null) return 0;
    if (va == null) return 1;
    if (vb == null) return -1;
    if (typeof va === 'number' && typeof vb === 'number') {
      return (va - vb) * dir;
    }
    return String(va).localeCompare(String(vb), 'ja') * dir;
  });
}

function getDisplayBillingRows() {
  const merged = getMergedBillingRows();
  return sortBillingRows(merged);
}

function calculateBillingSummary(rows) {
  return (rows || []).reduce((acc, row) => {
    if (!row || typeof row !== 'object') return acc;
    acc.totalVisits += Number(row.visitCount) || 0;
    acc.totalGrandTotal += Number(row.grandTotal) || 0;
    return acc;
  }, { totalVisits: 0, totalGrandTotal: 0 });
}

function toggleBillingSort(field) {
  if (!field) return;
  const current = billingState.sort || {};
  if (current.field === field) {
    billingState.sort = { field, direction: current.direction === 'asc' ? 'desc' : 'asc' };
  } else {
    billingState.sort = { field, direction: 'asc' };
  }
  renderBillingResult();
}

function calculateBillingRowTotalsLocal(row) {
  const source = row && typeof row === 'object' ? row : {};
  const insuranceType = source.insuranceType ? String(source.insuranceType).trim() : '';
  const burdenRate = normalizeBurdenRateInt(source.burdenRate);
  const visitCount = normalizeVisitCount(source.visitCount);
  const medicalAssistance = normalizeMedicalAssistanceFlag(source.medicalAssistance);
  const carryOverAmount = normalizeMoneyNumber(source.carryOverAmount)
    + normalizeMoneyNumber(source.carryOverFromHistory);

  const manualTransportInput = Object.prototype.hasOwnProperty.call(source, 'manualTransportAmount')
    ? source.manualTransportAmount
    : source.transportAmount;
  const normalizedManualTransport = (manualTransportInput === '' || manualTransportInput === null || manualTransportInput === undefined)
    ? null
    : normalizeMoneyNumber(manualTransportInput);
  const hasManualTransport = manualTransportInput !== ''
    && manualTransportInput !== null
    && manualTransportInput !== undefined
    && Number.isFinite(normalizedManualTransport);

  const manualUnitPriceInput = Object.prototype.hasOwnProperty.call(source, 'manualUnitPrice')
    ? source.manualUnitPrice
    : source.unitPrice;
  const normalizedManualUnitPrice = (manualUnitPriceInput === '' || manualUnitPriceInput === null)
    ? null
    : normalizeMoneyNumber(manualUnitPriceInput);
  const hasManualUnitPrice = manualUnitPriceInput !== ''
    && manualUnitPriceInput !== null
    && Number.isFinite(normalizedManualUnitPrice)
    && normalizedManualUnitPrice !== 0;

  const patientUnitPrice = normalizeMoneyNumber(source.unitPrice);
  const isSelfPaid = insuranceType === '自費' || burdenRate === '自費';

  let treatmentUnitPrice = 0;
  if (insuranceType === 'マッサージ') {
    treatmentUnitPrice = 0;
  } else if (hasManualUnitPrice) {
    treatmentUnitPrice = normalizedManualUnitPrice;
  } else if (medicalAssistance) {
    treatmentUnitPrice = 0;
  } else if (isSelfPaid) {
    treatmentUnitPrice = 0;
  } else if (Number.isFinite(patientUnitPrice) && patientUnitPrice !== 0) {
    treatmentUnitPrice = patientUnitPrice;
  } else {
    treatmentUnitPrice = BILLING_UNIT_PRICE;
  }

  const hasChargeablePrice = Number.isFinite(treatmentUnitPrice) && treatmentUnitPrice !== 0;
  const treatmentAmountFull = hasChargeablePrice && visitCount > 0 ? treatmentUnitPrice * visitCount : 0;
  const burdenMultiplier = isSelfPaid ? 1 : (Number.isFinite(burdenRate) && burdenRate > 0 ? burdenRate / 10 : 0);
  const treatmentAmount = isSelfPaid
    ? treatmentAmountFull
    : treatmentAmountFull * burdenMultiplier;
  const transportAmount = hasManualTransport
    ? normalizedManualTransport
    : hasChargeablePrice && visitCount > 0
      ? BILLING_TRANSPORT_UNIT_PRICE * visitCount
      : 0;
  const manualSelfPayAmount = normalizeMoneyNumber(source.manualSelfPayAmount);
  const grandTotal = carryOverAmount + treatmentAmount + transportAmount + manualSelfPayAmount;

  return { visitCount, treatmentUnitPrice, treatmentAmount, transportAmount, manualSelfPayAmount, grandTotal };
}

function normalizeServerBillingTotals(result, fallback) {
  const payload = result && typeof result === 'object' ? result : {};
  const base = fallback && typeof fallback === 'object' ? fallback : {};
  return {
    visitCount: Number(payload.visitCount != null ? payload.visitCount : payload.visits) || base.visitCount || 0,
    treatmentUnitPrice: Number(payload.treatmentUnitPrice != null ? payload.treatmentUnitPrice : payload.unitPrice)
      || base.treatmentUnitPrice
      || 0,
    treatmentAmount: Number(payload.treatmentAmount) || base.treatmentAmount || 0,
    transportAmount: Number(payload.transportAmount) || base.transportAmount || 0,
    carryOverAmount: Number(payload.carryOverAmount) || base.carryOverAmount || 0,
    billingAmount: Number(payload.billingAmount) || base.billingAmount || 0,
    manualSelfPayAmount: Number(payload.manualSelfPayAmount) || base.manualSelfPayAmount || 0,
    grandTotal: Number(payload.grandTotal) || base.grandTotal || 0
  };
}

function resetBillingEdits() {
  billingState.edits = {};
  billingState.patientInfoEdits = {};
  billingState.billingOverrideEdits = {};
  billingState.previewTotals = {};
  billingState.editing = null;
}

function getBillingEditTarget(field) {
  if (!field) return null;
  if (BILLING_PATIENT_INFO_FIELDS.indexOf(field) >= 0) return 'patientInfo';
  if (BILLING_BILLING_OVERRIDES_FIELDS.indexOf(field) >= 0) return 'billingOverrides';
  return null;
}

function resolvePatientInfoEditFields(field, value) {
  if (!field) return {};
  if (field === 'bankInfo' && value && typeof value === 'object') {
    return {
      bankCode: value.bankCode,
      branchCode: value.branchCode,
      accountNumber: value.accountNumber
    };
  }
  return { [field]: value };
}

function resolveBillingOverrideFields(field, value) {
  switch (field) {
    case 'unitPrice':
      return { manualUnitPrice: value };
    case 'transportAmount':
      return { manualTransportAmount: value === '' ? '' : value };
    case 'visitCount':
      return { visitCount: value };
    case 'carryOverAmount':
      return { carryOverAmount: value };
    case 'selfPayAmount':
      return { manualSelfPayAmount: value === '' ? '' : value };
    default:
      return {};
  }
}

function recordBillingEditForPersistence(patientId, field, value) {
  const target = getBillingEditTarget(field);
  const pid = String(patientId || '').trim();
  if (!pid || !target) return;

  if (target === 'patientInfo') {
    const current = billingState.patientInfoEdits[pid] || {};
    billingState.patientInfoEdits[pid] = Object.assign({}, current, resolvePatientInfoEditFields(field, value));
    return;
  }

  if (target === 'billingOverrides') {
    const current = billingState.billingOverrideEdits[pid] || {};
    billingState.billingOverrideEdits[pid] = Object.assign({}, current, resolveBillingOverrideFields(field, value));
  }
}

function buildBillingSavePayload() {
  const patientInfoUpdates = Object.keys(billingState.patientInfoEdits || {}).map(pid =>
    Object.assign({ patientId: pid }, billingState.patientInfoEdits[pid])
  );
  const billingOverridesUpdates = Object.keys(billingState.billingOverrideEdits || {}).map(pid =>
    Object.assign({ patientId: pid }, billingState.billingOverrideEdits[pid])
  );
  return { patientInfoUpdates, billingOverridesUpdates };
}

function recalculateBillingRow(patientId) {
  const pid = String(patientId || '').trim();
  if (!pid) return;
  const baseRows = Array.isArray(billingState.result && billingState.result.billingJson)
    ? billingState.result.billingJson
    : [];
  const baseRow = baseRows.find(row => String(row && row.patientId ? row.patientId : '') === pid) || {};
  const edits = billingState.edits[pid] || {};
  const merged = Object.assign({}, baseRow, edits);
  const fallbackTotals = calculateBillingRowTotalsLocal(merged);
  billingState.previewTotals[pid] = fallbackTotals;

  const scriptRun = typeof google !== 'undefined' && google.script && google.script.run;
  if (scriptRun && typeof google.script.run.calculateBillingRowTotalsServer === 'function') {
    google.script.run
      .withSuccessHandler(function(result) {
        billingState.previewTotals[pid] = normalizeServerBillingTotals(result, fallbackTotals);
        renderBillingResult();
      })
      .withFailureHandler(function(err) {
        console.error('Failed to calculate billing totals on server', err);
      })
      .calculateBillingRowTotalsServer(merged);
  }
}

function commitBillingEdit(patientId, field, value) {
  const pid = String(patientId || '').trim();
  if (!pid) return;
  const currentEdits = billingState.edits[pid] || {};
  const baseUpdate = Object.assign({}, currentEdits, { [field]: value });
  if (field === 'unitPrice') {
    baseUpdate.manualUnitPrice = value;
  }
  if (field === 'transportAmount') {
    baseUpdate.manualTransportAmount = value === '' ? '' : value;
  }
  if (field === 'selfPayAmount') {
    baseUpdate.manualSelfPayAmount = value === '' ? '' : value;
  }
  recordBillingEditForPersistence(pid, field, value);
  billingState.edits[pid] = baseUpdate;
  billingState.editing = null;
  recalculateBillingRow(pid);
  renderBillingResult();
}

function startBillingEdit(patientId, field) {
  billingState.editing = { patientId, field };
  renderBillingResult();
}

function ensureBillingRoute() {
  // Routing is managed in-memory to avoid sandboxed URL mutations that raise SecurityError.
  if (typeof window !== 'undefined') {
    window.APP_CONFIG = Object.assign({}, window.APP_CONFIG, { view: 'billing' });
  }
}

function loadBillingPage() {
  initBillingPage();
}

function normalizeBillingResultPayload(raw) {
  if (!raw) return null;

  const BILLING_ROW_DEFAULTS = {
    billingMonth: '',
    patientId: '',
    nameKanji: '',
    nameKana: '',
    address: '',
    insuranceType: '',
    burdenRate: 0,
    medicalAssistance: 0,
    manualUnitPrice: '',
    manualTransportAmount: '',
    manualSelfPayAmount: '',
    selfPayItems: [],
    unitPrice: 0,
    visitCount: 0,
    treatmentAmount: 0,
    transportAmount: 0,
    selfPayTotal: 0,
    carryOverAmount: 0,
    carryOverFromHistory: 0,
    billingAmount: 0,
    total: 0,
    grandTotal: 0,
    responsibleEmail: '',
    responsibleNames: [],
    responsibleName: '',
    payerType: '',
    bankStatus: '',
    paidStatus: '',
    bankCode: '',
    branchCode: '',
    accountNumber: '',
    isNew: 0
  };

  function applyBillingFieldDefaults(payload) {
    if (!payload || typeof payload !== 'object') return payload;
    return Object.assign(
      {
        staffByPatient: {},
        staffDirectory: {},
        staffDisplayByPatient: {},
        patients: {},
        bankInfoByName: {},
        bankStatuses: {},
        carryOverByPatient: {},
        billingOverrideFlags: {}
      },
      payload,
      {
        staffByPatient: payload.staffByPatient || {},
        staffDirectory: payload.staffDirectory || {},
        staffDisplayByPatient: payload.staffDisplayByPatient || {},
        patients: payload.patients || payload.patientMap || {},
        bankInfoByName: payload.bankInfoByName || {},
        bankStatuses: payload.bankStatuses || {},
        carryOverByPatient: payload.carryOverByPatient || {},
        billingOverrideFlags: payload.billingOverrideFlags || {}
      }
    );
  }

  function normalizeManualUnitPriceValue(value) {
    if (value === null || value === undefined || value === '') return '';
    return normalizeMoneyNumber(value);
  }

  function normalizeManualTransportAmountValue(value) {
    if (value === null || value === undefined || value === '') return '';
    return normalizeMoneyNumber(value);
  }

  function normalizeManualSelfPayAmountValue(value) {
    if (value === null || value === undefined || value === '') return '';
    return normalizeMoneyNumber(value);
  }

  function mergePatientMetaIntoRows(rows, patients) {
    if (!Array.isArray(rows)) return [];
    return rows.map(row => {
      const pid = row && row.patientId ? String(row.patientId).trim() : '';
      const patient = pid && patients ? patients[pid] || {} : {};

      const patientSeed = {
        patientId: pid || patient.patientId || '',
        nameKanji: patient.nameKanji,
        nameKana: patient.nameKana,
        address: patient.address,
        insuranceType: patient.insuranceType,
        burdenRate: patient.burdenRate,
        medicalAssistance: patient.medicalAssistance,
        manualUnitPrice: patient.manualUnitPrice != null ? patient.manualUnitPrice : patient.unitPrice,
        manualTransportAmount: patient.manualTransportAmount,
        manualSelfPayAmount: patient.manualSelfPayAmount,
        selfPayItems: patient.selfPayItems,
        unitPrice: patient.unitPrice,
        visitCount: patient.visitCount,
        carryOverAmount: patient.carryOverAmount,
        carryOverFromHistory: patient.carryOverFromHistory,
        payerType: patient.payerType,
        responsibleEmail: patient.responsibleEmail,
        responsibleNames: patient.responsibleNames,
        responsibleName: patient.responsibleName,
        bankStatus: patient.bankStatus,
        paidStatus: patient.paidStatus,
        bankCode: patient.bankCode,
        branchCode: patient.branchCode,
        accountNumber: patient.accountNumber,
        isNew: patient.isNew
      };

      const merged = Object.assign({}, BILLING_ROW_DEFAULTS, patientSeed, row || {});

      const burdenSource = row && row.hasOwnProperty('burdenRate') ? row.burdenRate : patient.burdenRate;
      merged.burdenRate = burdenSource === '自費' ? '自費' : normalizeBurdenRateInt(burdenSource);

      const assistanceSource = row && row.hasOwnProperty('medicalAssistance')
        ? row.medicalAssistance
        : patient.medicalAssistance;
      merged.medicalAssistance = normalizeMedicalAssistanceFlag(assistanceSource);

      const manualPriceSource = row && row.hasOwnProperty('manualUnitPrice')
        ? row.manualUnitPrice
        : patientSeed.manualUnitPrice;
      merged.manualUnitPrice = normalizeManualUnitPriceValue(manualPriceSource);

      const manualTransportSource = row && row.hasOwnProperty('manualTransportAmount')
        ? row.manualTransportAmount
        : patientSeed.manualTransportAmount;
      merged.manualTransportAmount = normalizeManualTransportAmountValue(manualTransportSource);

      const manualSelfPaySource = row && row.hasOwnProperty('manualSelfPayAmount')
        ? row.manualSelfPayAmount
        : patientSeed.manualSelfPayAmount;
      merged.manualSelfPayAmount = normalizeManualSelfPayAmountValue(manualSelfPaySource);
      merged.selfPayItems = Array.isArray(row && row.selfPayItems)
        ? row.selfPayItems
        : Array.isArray(patientSeed.selfPayItems) ? patientSeed.selfPayItems : [];

      merged.insuranceType = (row && row.insuranceType) || patient.insuranceType || '';
      merged.responsibleNames = Array.isArray(merged.responsibleNames) ? merged.responsibleNames : [];
      merged.bankCode = merged.bankCode || '';
      merged.branchCode = merged.branchCode || '';
      merged.accountNumber = merged.accountNumber || '';
      merged.isNew = merged.isNew === 1 || merged.isNew === '1' || merged.isNew === true ? 1 : 0;

      return merged;
    });
  }

  function normalizeBillingPayload(payload) {
    const withDefaults = applyBillingFieldDefaults(payload);
    const billingJson = coerceBillingJson(withDefaults.billingJson) || [];
    const fallbackBillingMonth = billingJson && billingJson.length ? billingJson[0].billingMonth : '';
    const resolvedBillingMonth =
      withDefaults.billingMonth ||
      (withDefaults.month && withDefaults.month.key) ||
      fallbackBillingMonth ||
      '';
    const receiptStatus = (withDefaults && withDefaults.receiptStatus)
      ? String(withDefaults.receiptStatus).trim().toUpperCase()
      : '';
    const aggregateUntilMonth = normalizeYm(withDefaults && withDefaults.aggregateUntilMonth
      ? String(withDefaults.aggregateUntilMonth)
      : '');
    const enrichedRows = mergePatientMetaIntoRows(billingJson, withDefaults.patients || {});
    const merged = Object.assign({}, withDefaults, {
      billingMonth: resolvedBillingMonth,
      billingJson: enrichedRows,
      receiptStatus,
      aggregateUntilMonth
    });
    if (Array.isArray(merged.billingJson)) {
      merged.billingJson = merged.billingJson.map(row => Object.assign({}, row || {}, {
        receiptStatus,
        aggregateUntilMonth
      }));
    }
    return merged;
  }

  function parseMaybeJson(value) {
    if (typeof value !== 'string') return value;
    try {
      return JSON.parse(value);
    } catch (err) {
      const msg = err && err.message ? err.message : err;
      console.warn('Failed to parse billing payload text:', msg);
      return null;
    }
  }

  function coerceBillingJson(value) {
    if (Array.isArray(value)) return value;
    if (typeof value === 'string') {
      try {
        const parsed = JSON.parse(value);
        return Array.isArray(parsed) ? parsed : null;
      } catch (err) {
        const msg = err && err.message ? err.message : err;
        console.warn('Failed to parse billingJson string:', msg);
        return null;
      }
    }
    return null;
  }

  function findBillingPayload(root, metaSource) {
    const queue = [];
    const visited = new WeakSet();

    const OBJECT_META_FIELDS = [
      'staffByPatient',
      'staffDirectory',
      'staffDisplayByPatient',
      'patients',
      'patientMap',
      'bankInfoByName',
      'bankStatuses',
      'carryOverByPatient'
    ];
    const ARRAY_META_FIELDS = ['files'];

    function extractMetaFields(source) {
      if (!source || typeof source !== 'object') return {};
      const meta = {};
      Object.keys(source).forEach(key => {
        const value = source[key];
        const type = typeof value;
        const isDate = Object.prototype.toString.call(value) === '[object Date]';
        const isPlainObject = value && !Array.isArray(value) && !isDate && type === 'object';
        if (OBJECT_META_FIELDS.includes(key) && isPlainObject) {
          meta[key] = value;
        } else if (ARRAY_META_FIELDS.includes(key) && Array.isArray(value)) {
          meta[key] = value;
        } else if (value === null || type === 'string' || type === 'number' || type === 'boolean' || isDate) {
          meta[key] = value;
        }
      });

      ['meta', 'metadata'].forEach(nestedKey => {
        const nested = source[nestedKey];
        if (nested && typeof nested === 'object') {
          Object.assign(meta, extractMetaFields(nested));
        }
      });
      return meta;
    }

    function mergeWithMeta(obj, meta) {
      const billingJson = coerceBillingJson(obj.billingJson);
      if (!billingJson) return null;
      return normalizeBillingPayload(Object.assign({}, meta, obj, { billingJson }));
    }

    function enqueue(candidate, inheritedMeta) {
      const parsed = parseMaybeJson(candidate);
      const value = parsed === null ? candidate : parsed;
      if (value && typeof value === 'object' && !visited.has(value)) {
        visited.add(value);
        const meta = Object.assign({}, inheritedMeta, extractMetaFields(value));
        queue.push({ obj: value, meta });
      }
    }

    const initialMeta = extractMetaFields(metaSource);
    enqueue(root, initialMeta);

    while (queue.length) {
      const { obj, meta } = queue.shift();
      const merged = mergeWithMeta(obj, meta);
      if (merged) {
        return merged;
      }

      Object.keys(obj).forEach(key => {
        const value = obj[key];
        enqueue(value, meta);
      });
    }

    return null;
  }

  let result = parseMaybeJson(raw);
  if (result == null) return null;

  if (Array.isArray(result)) {
    return normalizeBillingPayload({ billingJson: result, billingMonth: '', preparedAt: null });
  }

  const found = findBillingPayload(result, result);
  if (found && found.billingJson) {
    return normalizeBillingPayload(found);
  }

  const billingJson = coerceBillingJson(result.billingJson) || [];
  if (!billingJson.length) {
    console.warn('[billing] billingJson not found in payload; returning empty array');
  }
  return normalizeBillingPayload(Object.assign({}, result, { billingJson }));
}

function syncReceiptStateFromPayload(payload) {
  const status = payload && payload.receiptStatus ? String(payload.receiptStatus).trim().toUpperCase() : '';
  const aggregate = payload && payload.aggregateUntilMonth ? normalizeYm(payload.aggregateUntilMonth) : '';
  billingState.receiptStatus = status;
  billingState.aggregateUntilMonth = aggregate;
}

function handleBillingAggregation() {
  if (shouldBlockFinalizedBillingOperation()) return;
  const ym = normalizeYm(qs('billingMonth').value);
  if (!ym) {
    alert('請求月を入力してください (YYYY-MM)');
    return;
  }
  logBillingState('handleBillingAggregation:start', { ym });
  setBillingLoading(true, '集計中…');
  google.script.run
    .withSuccessHandler(function(result) {
      logBillingState('prepareBillingData:success', { ym });
      onBillingPrepared(result);
    })
    .withFailureHandler(function(err) {
      logBillingState('prepareBillingData:error', { ym, error: err && err.message ? err.message : err });
      onBillingFailed(err);
    })
    .prepareBillingData(ym);
}

function onBillingPrepared(result) {
  console.warn('[billing-debug] raw result = ', JSON.stringify(result, null, 2).slice(0, 5000));
  try {
    const normalized = normalizeBillingResultPayload(result);
    billingState.result = normalized;
    billingState.prepared = normalized;
    syncReceiptStateFromPayload(normalized);
    billingState.loading = false;
    billingState.statusMessage = '集計が完了しました。内容確認後にPDFを生成してください。';
    billingState.errorMessage = '';
    resetBillingEdits();
    logBillingState('onBillingPrepared', { rows: normalized && normalized.billingJson ? normalized.billingJson.length : 0 });
    renderBillingResult();
  } catch (err) {
    billingState.loading = false;
    billingState.statusMessage = '集計データの処理に失敗しました';
    setBillingError('集計結果の整形中にエラーが発生しました', err);
  }
}

function handleBillingPdfGeneration() {
  if (!billingState.prepared || !billingState.prepared.billingMonth) {
    alert('先に「請求データを集計」を実行してください。');
    return;
  }

  if (shouldBlockFinalizedBillingOperation()) return;

  const invoiceMode = getInvoiceMode();
  const invoicePatientIdsText = getInvoicePatientIdsInput();
  const invoicePatientIds = invoiceMode === 'partial' ? normalizeInvoicePatientIdsInput(invoicePatientIdsText) : [];

  if (invoiceMode === 'partial' && !invoicePatientIds.length) {
    alert('個別再発行を選択した場合、対象の患者IDを入力してください。');
    return;
  }

  billingState.invoiceMode = invoiceMode;
  billingState.invoicePatientIdsInput = invoicePatientIdsText;
  setBillingLoading(true, 'PDF生成中…');
  const payload = Object.assign({}, buildBillingSavePayload(), {
    invoiceMode,
    invoicePatientIds
  });
  google.script.run
    .withSuccessHandler(onBillingPdfCompleted)
    .withFailureHandler(onBillingFailed)
    .applyBillingEditsAndGenerateInvoices(billingState.prepared.billingMonth, payload);
}

function onBillingPdfCompleted(result) {
  try {
    const normalized = normalizeBillingResultPayload(result) || billingState.prepared || null;
    billingState.result = normalized;
    billingState.prepared = normalized;
    syncReceiptStateFromPayload(normalized);
    billingState.loading = false;
    billingState.statusMessage = 'PDF生成と担当者フォルダへの保存が完了しました';
    billingState.errorMessage = '';
    resetBillingEdits();
    logBillingState('onBillingPdfCompleted', { rows: normalized && normalized.billingJson ? normalized.billingJson.length : 0 });
    renderBillingResult();
  } catch (err) {
    billingState.loading = false;
    billingState.statusMessage = 'PDF生成結果の処理に失敗しました';
    setBillingError('PDF生成後の結果処理でエラーが発生しました', err);
  }
}

function handleBillingSaveEdits() {
  if (!billingState.prepared || !billingState.prepared.billingMonth) {
    alert('先に「請求データを集計」を実行してください。');
    return;
  }
  setBillingLoading(true, '保存中…');
  google.script.run
    .withSuccessHandler(onBillingSaveCompleted)
    .withFailureHandler(onBillingFailed)
    .applyBillingEdits(billingState.prepared.billingMonth, buildBillingSavePayload());
}

function onBillingSaveCompleted(result) {
  const nextResult = result || billingState.result || null;
  if (nextResult) {
    billingState.result = nextResult;
    billingState.prepared = nextResult;
  }
  syncReceiptStateFromPayload(nextResult);
  billingState.loading = false;
  billingState.statusMessage = '保存が完了しました';
  billingState.errorMessage = '';
  resetBillingEdits();
  const rowCount = billingState.prepared && billingState.prepared.billingJson
    ? billingState.prepared.billingJson.length
    : 0;
  logBillingState('onBillingSaveCompleted', { rows: rowCount });
  renderBillingResult();
}

function handleBillingFinalize(patientId) {
  if (!billingState.prepared || !billingState.prepared.billingMonth) {
    alert('先に「請求データを集計」を実行してください。');
    return;
  }
  const pid = String(patientId || '').trim();
  if (!pid) return;
  if (!confirm('この患者の請求を確定します。確定解除はできません。')) return;

  setBillingLoading(true, '確定処理中…');
  google.script.run
    .withSuccessHandler(function(result) {
      const normalized = normalizeBillingResultPayload(result) || billingState.prepared || null;
      billingState.result = normalized;
      billingState.prepared = normalized;
      syncReceiptStateFromPayload(normalized);
      billingState.loading = false;
      billingState.statusMessage = '請求を確定しました';
      billingState.errorMessage = '';
      resetBillingEdits();
      renderBillingResult();
    })
    .withFailureHandler(onBillingFailed)
    .finalizeBillingEntry(billingState.prepared.billingMonth, pid);
}

function handleBankFlowAggregation() {
  const ym = getBankTargetMonth();
  if (!ym) {
    alert('対象月を入力してください (YYYY-MM)');
    return;
  }
  bankFlowState.targetMonth = ym;
  setBankLoading(true, '請求データ集計中…');
  google.script.run
    .withSuccessHandler(function(result) {
      bankFlowState.aggregation = result || null;
      bankFlowState.sheet = null;
      bankFlowState.finalized = null;
      bankFlowState.status = '請求データ集計が完了しました。銀行引落シート生成へ進んでください。';
      bankFlowState.loading = false;
      renderBankFlowDetail();
      updateBankControls();
    })
    .withFailureHandler(function(err) {
      setBankError('請求データ集計に失敗しました', err);
    })
    .prepareBankWithdrawalData(ym);
}

function handleBankSheetGeneration() {
  const ym = getBankTargetMonth();
  if (!ym) {
    alert('対象月を入力してください (YYYY-MM)');
    return;
  }
  const summary = getBankSheetSummary();
  if (summary && summary.exists && summary.billingMonth === ym) {
    alert('この月の銀行引落シートは既に生成済みです。対象月を変更してください。');
    return;
  }
  bankFlowState.targetMonth = ym;
  setBankLoading(true, '銀行引落シート生成中…');
  google.script.run
    .withSuccessHandler(function(result) {
      bankFlowState.sheet = result || null;
      bankFlowState.status = '銀行引落シートを生成しました。未回収チェックなどを行ってください。';
      bankFlowState.loading = false;
      renderBankFlowDetail();
      updateBankControls();
    })
    .withFailureHandler(function(err) {
      setBankError('銀行引落シート生成に失敗しました', err);
    })
    .generateBankWithdrawalSheetFromCache(ym);
}

function handleBankFinalize() {
  const ym = getBankTargetMonth();
  if (!ym) {
    alert('対象月を入力してください (YYYY-MM)');
    return;
  }
  bankFlowState.targetMonth = ym;
  setBankLoading(true, '確定処理中…');
  google.script.run
    .withSuccessHandler(function(result) {
      bankFlowState.finalized = result || null;
      bankFlowState.status = '当月の銀行引落データを確定としてマークしました。';
      bankFlowState.loading = false;
      renderBankFlowDetail();
      updateBankControls();
    })
    .withFailureHandler(function(err) {
      setBankError('確定処理に失敗しました', err);
    })
    .confirmBankWithdrawalDataReady(ym);
}

function handleBankUnpaidApply() {
  const ym = getBankTargetMonth();
  if (!ym) {
    alert('対象月を入力してください (YYYY-MM)');
    return;
  }
  bankFlowState.targetMonth = ym;
  setBankLoading(true, '未回収履歴へ反映中…');
  google.script.run
    .withSuccessHandler(function(result) {
      bankFlowState.unpaid = result || null;
      bankFlowState.status = '未回収履歴へ反映しました。';
      bankFlowState.loading = false;
      renderBankFlowDetail();
      updateBankControls();
    })
    .withFailureHandler(function(err) {
      setBankError('未回収履歴への反映に失敗しました', err);
    })
    .applyBankWithdrawalUnpaidFromUi(ym);
}

function onBillingFailed(err) {
  console.error('[billing generation failed]', err);
  const msg = err && err.message ? err.message : String(err);
  billingState.loading = false;
  billingState.statusMessage = '請求処理に失敗しました';
  setBillingError('請求処理でエラーが発生しました', msg);
  alert('請求生成に失敗しました: ' + msg);
}

function formatCurrency(value) {
  const num = Number(value);
  if (!Number.isFinite(num)) return '-';
  return num.toLocaleString('ja-JP') + ' 円';
}

function renderBillingStatus(result) {
  const el = qs('billingStatus');
  if (!el) return;
  if (billingState.errorMessage) {
    el.textContent = '';
    return;
  }
  if (billingState.loading) {
    el.innerHTML = `<span class="loading"><span class="spinner"></span>${billingState.statusMessage || '生成中…'}</span>`;
    return;
  }
  if (billingState.statusMessage) {
    el.textContent = billingState.statusMessage;
    return;
  }
  if (billingState.prepared) {
    el.textContent = result && result.files && result.files.length
      ? 'PDF生成が完了しました'
      : '集計済み（PDF未生成）';
    return;
  }
  el.textContent = '';
}

function renderCarryOverLedgerStatus() {
  const badge = qs('carryOverLedgerStatus');
  if (!badge) return;
  const meta = billingState.prepared && billingState.prepared.carryOverLedgerMeta
    ? billingState.prepared.carryOverLedgerMeta
    : null;
  const hasMeta = meta && Object.keys(meta).length > 0;
  if (!billingState.prepared || !hasMeta) {
    badge.style.display = 'none';
    badge.textContent = '';
    badge.removeAttribute('title');
    return;
  }
  const loadError = meta.loadError;
  const wasAutoCreated = !!meta.wasAutoCreated;
  const headerInserted = !!meta.headerInserted;
  const dataRowCount = Number(meta.dataRowCount || 0);
  const wasInitialized = wasAutoCreated || headerInserted;

  if (loadError) {
    badge.className = 'pill warn';
    badge.textContent = 'Ledger 読み込みエラー';
    badge.title = loadError;
    badge.style.display = 'inline-flex';
    return;
  }
  if (wasInitialized) {
    badge.className = 'pill warn';
    badge.textContent = 'Ledger 未作成 → 自動初期化';
    badge.title = 'CarryOverLedger シートが見つからなかったため、自動で作成または初期化しました。';
    badge.style.display = 'inline-flex';
    return;
  }

  badge.className = dataRowCount > 0 ? 'pill ok' : 'pill neutral';
  badge.textContent = dataRowCount > 0 ? `Ledger OK（${dataRowCount}件）` : 'Ledger 0件（作成済み）';
  badge.title = dataRowCount > 0
    ? 'CarryOverLedger の読み込みに成功しました'
    : 'CarryOverLedger は空ですが作成済みです';
  badge.style.display = 'inline-flex';
}

function renderBillingError() {
  const box = qs('billingError');
  if (!box) return;
  const msg = billingState.errorMessage;
  if (msg) {
    box.style.display = '';
    box.innerHTML = `<strong>請求処理中にエラーが発生しました。</strong><div>${escapeHtml(msg)}</div>`;
    return;
  }
  box.style.display = 'none';
  box.textContent = '';
}

function renderDownloads(result) {
  const box = qs('downloads');
  if (!box) return;
  box.innerHTML = '';
  if (billingState.loading) {
    box.innerHTML = `<div class="loading"><span class="spinner"></span>ファイル生成中…</div>`;
    return;
  }
  const files = (result && Array.isArray(result.files)) ? result.files.filter(file => file && file.url) : [];
  if (!files.length) {
    box.innerHTML = billingState.prepared
      ? '<div class="muted">集計済みです。PDF生成ボタンを押してください。</div>'
      : '<div class="muted">出力ファイルはまだありません。</div>';
    return;
  }
  box.innerHTML = files.map(link => `
    <a class="download-link" href="${link.url}" target="_blank" rel="noopener">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <path d="M12 3v14" /><path d="M5 10l7 7 7-7" /><path d="M5 21h14" />
      </svg>
      <div>
        <div>${link.name || '請求書PDF'}</div>
        <small class="muted" style="display:block;">${link.nameKanji || link.patientId || ''}</small>
      </div>
    </a>`).join('');
}

function renderMonthBadge(result) {
  const label = qs('billingMonthLabel');
  if (!label) return;
  if (result && result.billingMonth) {
    label.style.display = 'inline-flex';
    label.textContent = '請求月: ' + result.billingMonth;
  } else {
    label.style.display = 'none';
    label.textContent = '';
  }
}

function renderBillingSummary(rows) {
  const box = qs('billingSummary');
  if (!box) return;
  if (!rows || !rows.length) {
    box.style.display = 'none';
    box.innerHTML = '';
    return;
  }
  const summary = calculateBillingSummary(rows);
  box.style.display = '';
  box.innerHTML = `
    <div class="summary-card">
      <p class="summary-label">総施術回数</p>
      <p class="summary-value">${summary.totalVisits.toLocaleString()} 回</p>
    </div>
    <div class="summary-card">
      <p class="summary-label">請求合計金額</p>
      <p class="summary-value">${formatCurrency(summary.totalGrandTotal)}</p>
    </div>
  `;
}

function renderBillingResult() {
  logBillingState('renderBillingResult', {
    resultLength: billingState.result && billingState.result.billingJson ? billingState.result.billingJson.length : 0,
    preparedLength: billingState.prepared && billingState.prepared.billingJson ? billingState.prepared.billingJson.length : 0
  });
  updateBillingControls();
  const box = qs('billingResult');
  if (!box) return;
  const result = billingState.result;
    renderBillingError();
    renderBillingStatus(result);
    renderCarryOverLedgerStatus();
    renderDownloads(result);
    renderMonthBadge(result);
    renderBillingSummary(null);

  if (billingState.loading) {
    box.innerHTML = '<div class="loading"><span class="spinner"></span>請求データを生成中です…</div>';
    return;
  }
  if (billingState.errorMessage) {
    box.innerHTML = '<div class="alert danger">請求処理中にエラーが発生しました。詳細は上部のエラーメッセージをご確認ください。</div>';
    return;
  }
  if (!result || !result.billingJson || !result.billingJson.length) {
    renderBillingSummary(null);
    box.innerHTML = '<div class="muted">まだ請求を生成していません。</div>';
    return;
  }

  const rows = getDisplayBillingRows();
  renderBillingSummary(rows);
  const header = [
    { key: 'patientId', label: '患者ID', sortable: true },
    { key: 'nameKanji', label: '氏名', sortable: true },
    { key: 'responsible', label: '担当者', sortable: true },
    { key: 'medicalAssistance', label: '医療助成', sortable: false },
    { key: 'payerType', label: '保険者', sortable: false },
    { key: 'burdenRate', label: '負担', sortable: true },
    { key: 'visitCount', label: '回数', sortable: true },
    { key: 'unitPrice', label: '単価', sortable: true },
    { key: 'treatmentAmount', label: '施術料', sortable: true },
    { key: 'transportAmount', label: '交通費', sortable: true },
    { key: 'carryOverAmount', label: '繰越', sortable: true },
    { key: 'grandTotal', label: '合計', sortable: true },
    { key: 'paidStatus', label: '領収状態', sortable: false },
    { key: 'bankInfo', label: '口座情報', sortable: false },
    { key: 'isNew', label: '新規', sortable: false },
    { key: 'finalize', label: '確定', sortable: false }
  ];

  const columnCount = header.length;

  function renderSortHeaderCell(h) {
    if (!h.sortable) {
      return `<th>${h.label}</th>`;
    }
    const active = billingState.sort && billingState.sort.field === h.key;
    const indicator = active ? (billingState.sort.direction === 'asc' ? '▲' : '▼') : '';
    const thClass = h.sortable ? 'sortable' : '';
    return `<th class="${thClass}"><button type="button" class="sort-header" data-sort-key="${h.key}">${h.label}${indicator ? `<span class="sort-indicator">${indicator}</span>` : ''}</button></th>`;
  }

  function renderEditableCell(item, field, alignRight) {
    const finalized = isBillingRowFinalized(item);
    const editing = !finalized
      && billingState.editing
      && billingState.editing.patientId === item.patientId
      && billingState.editing.field === field;
    const baseAttrs = `data-edit-field="${field}" data-edit-patient="${item.patientId}"`;
    const editClass = alignRight ? 'cell-edit inline-editor right' : 'cell-edit inline-editor';
    const viewClass = alignRight ? 'cell-edit right' : 'cell-edit';
    if (editing) {
      if (field === 'burdenRate') {
        const editor = `<select class="${editClass}" ${baseAttrs}>${BILLING_BURDEN_OPTIONS.map(opt => `<option value="${opt.value}" ${String(opt.value) === String(item.burdenRate) ? 'selected' : ''}>${opt.label}</option>`).join('')}</select>`;
        const showSelfPay = String(item.burdenRate) === '自費' || String(item.insuranceType).trim() === '自費';
        const selfPayValue = item.manualSelfPayAmount === '' || item.manualSelfPayAmount === null || item.manualSelfPayAmount === undefined
          ? ''
          : normalizeEditNumber(item.manualSelfPayAmount);
        const selfPayAttrs = `data-edit-field="selfPayAmount" data-edit-patient="${item.patientId}"`;
        const selfPayEditor = showSelfPay
          ? wrapWithOverrideBadge(
            `<div class="selfpay-editor"><label>自費金額<input class="${editClass}" ${selfPayAttrs} type="number" step="10" value="${selfPayValue}" /></label></div>`,
            item.patientId,
            'selfPayAmount',
            alignRight
          )
          : '';
        return wrapWithOverrideBadge(`<div class="burden-editor">${editor}${selfPayEditor}</div>`, item.patientId, field, alignRight);
      }
      if (field === 'payerType') {
        const editor = `<select class="${editClass}" ${baseAttrs}>${BILLING_PAYER_OPTIONS.map(opt => `<option value="${opt}" ${opt === item.payerType ? 'selected' : ''}>${opt}</option>`).join('')}</select>`;
        return wrapWithOverrideBadge(editor, item.patientId, field, alignRight);
      }
      if (field === 'medicalAssistance') {
        const checked = normalizeMedicalAssistanceFlag(item.medicalAssistance) ? 'checked' : '';
        const editor = `<label class="${editClass}" style="display:flex;align-items:center;gap:6px;"><input type="checkbox" ${baseAttrs} ${checked} />医療助成</label>`;
        return wrapWithOverrideBadge(editor, item.patientId, field, alignRight);
      }
      if (field === 'unitPrice' || field === 'carryOverAmount') {
        const val = normalizeEditNumber(item[field]);
        const editor = `<input class="${editClass}" ${baseAttrs} type="number" step="10" value="${val}" />`;
        return wrapWithOverrideBadge(editor, item.patientId, field, alignRight);
      }
      if (field === 'transportAmount') {
        const val = item.manualTransportAmount === '' || item.manualTransportAmount === null || item.manualTransportAmount === undefined
          ? ''
          : normalizeEditNumber(item.manualTransportAmount);
        const placeholder = Number.isFinite(item.transportAmount) ? formatCurrency(item.transportAmount) : '';
        const editor = `<input class="${editClass}" ${baseAttrs} type="number" step="10" value="${val}" placeholder="${placeholder}" />`;
        return wrapWithOverrideBadge(editor, item.patientId, field, alignRight);
      }
    }

    const display = (() => {
      switch (field) {
        case 'medicalAssistance':
          return normalizeMedicalAssistanceFlag(item.medicalAssistance) ? '有' : 'なし';
        case 'burdenRate':
          if (String(item.burdenRate) === '自費') {
            const selfPayAmount = item.manualSelfPayAmount || 0;
            const label = normalizeBurdenRateDisplay(item.burdenRate) || '自費';
            return selfPayAmount ? `${label}（${formatCurrency(selfPayAmount)}円）` : label;
          }
          return normalizeBurdenRateDisplay(item.burdenRate) || '編集';
        case 'payerType':
          return item.payerType || '編集';
        case 'unitPrice':
          return formatCurrency(item.unitPrice);
        case 'transportAmount':
          return formatCurrency(item.transportAmount);
        case 'carryOverAmount':
          return formatCurrency(item.carryOverAmount);
        default:
          return item[field] || '';
      }
    })();

    if (finalized) {
      return wrapWithOverrideBadge(display, item.patientId, field, alignRight);
    }

    const view = `<button type="button" class="${viewClass}" ${baseAttrs} aria-label="${field} を編集">${display}</button>`;
    return wrapWithOverrideBadge(view, item.patientId, field, alignRight);
  }

  function renderFinalizeAction(item) {
    const finalized = isBillingRowFinalized(item);
    if (finalized) {
      const detailText = escapeHtml(getFinalizationDetailText(item));
      const source = item.finalizationSource ? String(item.finalizationSource).trim() : '';
      const sourceLabel = source ? ` (${escapeHtml(source)})` : '';
      if (detailText) {
        return `<div class="muted">確定済み${sourceLabel}<br><small>${detailText}</small></div>`;
      }
      return `<div class="muted">確定済み${sourceLabel}</div>`;
    }

    const disabled = billingState.loading || !billingState.prepared || !billingState.prepared.billingMonth;
    const title = disabled
      ? '先に「請求データを集計」を実行してください'
      : '確定すると再集計や自動上書きの対象外になります';
    return `<button type="button" class="btn small finalize-btn" data-finalize-patient="${item.patientId}" ${disabled ? 'disabled' : ''} title="${title}">確定</button>`;
  }

  const bodyRows = [];
  rows.forEach(item => {
    try {
      const safeItem = item && typeof item === 'object' ? item : {};
      const finalized = isBillingRowFinalized(safeItem);
      const rowClass = finalized ? ' class="finalized-row"' : '';
      const nameWithBadge = `${safeItem.nameKanji || ''}${renderReceiptStatusBadge(safeItem)}`;
      bodyRows.push(`
      <tr${rowClass}>
        <td>${safeItem.patientId || ''}</td>
        <td>${nameWithBadge}</td>
        <td>${getResponsibleDisplay(safeItem) || '—'}</td>
        <td>${renderEditableCell(safeItem, 'medicalAssistance')}</td>
        <td>${renderEditableCell(safeItem, 'payerType')}</td>
        <td>${renderEditableCell(safeItem, 'burdenRate')}</td>
        <td>${wrapWithOverrideBadge(safeItem.visitCount || 0, safeItem.patientId, 'visitCount')}</td>
        <td class="right">${renderEditableCell(safeItem, 'unitPrice', true)}</td>
        <td class="right">${formatCurrency(safeItem.treatmentAmount)}</td>
        <td class="right">${renderEditableCell(safeItem, 'transportAmount', true)}</td>
        <td class="right">${renderEditableCell(safeItem, 'carryOverAmount', true)}</td>
        <td class="right">${formatCurrency(safeItem.grandTotal)}</td>
        <td>${formatPaidStatus(safeItem) || '—'}</td>
        <td>${formatBankInfo(safeItem) || '—'}</td>
        <td>${formatNewFlag(safeItem) || ''}</td>
        <td>${renderFinalizeAction(safeItem)}</td>
      </tr>`);
    } catch (err) {
      console.error('Failed to render billing row', err, item);
      const pid = item && item.patientId ? `患者ID: ${item.patientId}` : '患者行の表示でエラーが発生しました';
      bodyRows.push(`<tr class="error-row"><td colspan="${columnCount}">${pid}</td></tr>`);
    }
  });

  const tableHtml = [
    '<table><thead><tr>',
    header.map(renderSortHeaderCell).join(''),
    '</tr></thead><tbody>',
    ...bodyRows,
    '</tbody></table>',
    renderBillingActionFooter(rows && rows.length > 0)
  ].join('');

  box.innerHTML = tableHtml;
  attachBillingEditHandlers();
  attachBillingSortHandlers();
  attachBillingFinalizeHandlers();
}

function renderBillingActionFooter(hasRows) {
  if (!hasRows) return '';
  const prepared = !!(billingState.prepared && billingState.prepared.billingMonth);
  const loading = billingState.loading;
  const saveDisabled = loading || !prepared;
  const pdfDisabled = loading || !prepared;
  const helper = prepared
    ? '編集を保存したら、そのままPDF生成へ進めます。'
    : '先に「請求データを集計」を実行すると保存・PDF生成が有効になります。';
  return `
    <div class="action-footer">
      <div>
        <div class="muted">${helper}</div>
      </div>
      <div class="action-buttons">
        <button class="btn secondary" type="button" onclick="handleBillingSaveEdits()" ${saveDisabled ? 'disabled' : ''}>変更を保存</button>
        <button class="btn" type="button" onclick="handleBillingPdfGeneration()" ${pdfDisabled ? 'disabled' : ''}>PDF生成＆担当者フォルダ保存</button>
      </div>
    </div>`;
}

function attachBillingEditHandlers() {
  const box = qs('billingResult');
  if (!box) return;
  box.querySelectorAll('button.cell-edit').forEach(btn => {
    btn.onclick = function () {
      const pid = this.getAttribute('data-edit-patient');
      const field = this.getAttribute('data-edit-field');
      startBillingEdit(pid, field);
    };
  });
  box.querySelectorAll('select.inline-editor, input.inline-editor').forEach(input => {
    input.onchange = function () {
      const pid = this.getAttribute('data-edit-patient');
      const field = this.getAttribute('data-edit-field');
      let value = this.value;
      if (this.type === 'checkbox') {
        value = normalizeMedicalAssistanceFlag(this.checked);
      }
      if (field === 'burdenRate') {
        value = value === '自費' ? '自費' : normalizeBurdenRateInt(value);
      }
      if (field === 'unitPrice' || field === 'carryOverAmount') {
        value = normalizeMoneyNumber(value);
      }
      if (field === 'transportAmount') {
        value = value === '' ? '' : normalizeMoneyNumber(value);
      }
      if (field === 'selfPayAmount') {
        value = value === '' ? '' : normalizeMoneyNumber(value);
      }
      if (field === 'visitCount') {
        value = normalizeVisitCount(value);
      }
      commitBillingEdit(pid, field, value);
    };
    input.onblur = input.onchange;
  });
}

function attachBillingFinalizeHandlers() {
  const box = qs('billingResult');
  if (!box) return;
  box.querySelectorAll('button.finalize-btn').forEach(btn => {
    btn.onclick = function () {
      const pid = this.getAttribute('data-finalize-patient');
      handleBillingFinalize(pid);
    };
  });
}

function attachBillingSortHandlers() {
  const box = qs('billingResult');
  if (!box) return;
  box.querySelectorAll('button.sort-header').forEach(btn => {
    btn.onclick = function () {
      const field = this.getAttribute('data-sort-key');
      toggleBillingSort(field);
    };
  });
}

function initBillingPage() {
  ensureBillingRoute();
  const input = qs('billingMonth');
  if (input && !input.value) {
    input.value = getDefaultMonth();
  }
  const bankMonthInput = qs('bankWithdrawalMonth');
  if (bankMonthInput && !bankMonthInput.value) {
    bankMonthInput.value = input && input.value ? input.value : getDefaultMonth();
  }
  if (bankMonthInput) {
    simpleBankState.targetMonth = normalizeYm(bankMonthInput.value);
    bankMonthInput.onchange = function () {
      simpleBankState.targetMonth = normalizeYm(this.value);
      updateSimpleBankControls();
      renderSimpleBankSummary();
    };
  }
  updateBillingControls();
  updateSimpleBankControls();
  renderBillingResult();
  renderSimpleBankDetail();
}

(function bootstrap() {
  const body = document.body;
  if (body && body.dataset) {
    window.APP_CONFIG = Object.assign({}, window.APP_CONFIG, {
      view: body.dataset.view || (window.APP_CONFIG && window.APP_CONFIG.view) || '',
      baseUrl: body.dataset.baseUrl || (window.APP_CONFIG && window.APP_CONFIG.baseUrl) || ''
    });
  }

  const view = (window.APP_CONFIG && window.APP_CONFIG.view) || '';
  if (view === 'billing') {
    initBillingPage();
  }
})();

const billingGlobal = typeof window !== 'undefined' ? window : null;
if (billingGlobal) {
  billingGlobal.loadBillingPage = loadBillingPage;
  billingGlobal.handleBillingAggregation = handleBillingAggregation;
  billingGlobal.handleBillingPdfGeneration = handleBillingPdfGeneration;
  billingGlobal.handleBillingSaveEdits = handleBillingSaveEdits;
  billingGlobal.handleBillingFinalize = handleBillingFinalize;
  billingGlobal.handleSimpleBankSheetGeneration = handleSimpleBankSheetGeneration;
}
</script>
