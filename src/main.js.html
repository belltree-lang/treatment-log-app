<script>
const billingState = {
  loading: false,
  result: null,
  prepared: null,
  statusMessage: '',
  edits: {},
  editing: null,
  sort: { field: null, direction: 'asc' }
};

const BILLING_INSURANCE_OPTIONS = ['後期高齢', '国保', '社保', '生保', '自費'];
const BILLING_DEPRECATED_INSURANCE_TYPES = ['マッサージ'];
const BILLING_BURDEN_OPTIONS = [
  { value: 1, label: '1割' },
  { value: 2, label: '2割' },
  { value: 3, label: '3割' },
  { value: '自費', label: '自費' }
];
const BILLING_PAYER_OPTIONS = ['保険', '自費'];
const BILLING_TREATMENT_PRICE = 4070;
const BILLING_ELECTRO_PRICE = 100;
const BILLING_UNIT_PRICE = BILLING_TREATMENT_PRICE + BILLING_ELECTRO_PRICE;
const BILLING_TRANSPORT_UNIT_PRICE_FALLBACK = 33;
const BILLING_TRANSPORT_UNIT_PRICE = (typeof globalThis !== 'undefined' && typeof globalThis.BILLING_TRANSPORT_UNIT_PRICE === 'number')
  ? globalThis.BILLING_TRANSPORT_UNIT_PRICE
  : BILLING_TRANSPORT_UNIT_PRICE_FALLBACK;

function qs(id) {
  return document.getElementById(id);
}

function getDefaultMonth() {
  const today = new Date();
  const prevMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1);
  const y = prevMonth.getFullYear();
  const m = String(prevMonth.getMonth() + 1).padStart(2, '0');
  return y + '-' + m;
}

function updateBillingControls() {
  const monthInput = qs('billingMonth');
  const aggregateBtn = qs('billingAggregateBtn');
  const pdfBtn = qs('billingPdfBtn');
  const saveBtn = qs('billingSaveBtn');
  const bankBtn = qs('billingBankBtn');
  const loading = billingState.loading;
  const prepared = !!(billingState.prepared && billingState.prepared.billingMonth);

  if (monthInput) {
    monthInput.disabled = loading;
  }
  if (aggregateBtn) {
    aggregateBtn.disabled = loading;
    aggregateBtn.setAttribute('aria-busy', loading ? 'true' : 'false');
  }
  if (pdfBtn) {
    const disabled = loading || !prepared;
    pdfBtn.disabled = disabled;
    pdfBtn.setAttribute('aria-busy', loading ? 'true' : 'false');
    pdfBtn.title = disabled && !prepared ? '先に「請求データを集計」を実行してください' : '';
  }
  if (saveBtn) {
    const disabled = loading || !prepared;
    saveBtn.disabled = disabled;
    saveBtn.setAttribute('aria-busy', loading ? 'true' : 'false');
    saveBtn.title = disabled && !prepared ? '先に「請求データを集計」を実行してください' : '';
  }
  if (bankBtn) {
    const disabled = loading || !prepared;
    bankBtn.disabled = disabled;
    bankBtn.setAttribute('aria-busy', loading ? 'true' : 'false');
    bankBtn.title = disabled && !prepared ? '先に「請求データを集計」を実行してください' : '';
  }
}

function normalizeYm(raw) {
  if (!raw) return '';
  const cleaned = String(raw).replace(/[^0-9]/g, '');
  if (cleaned.length === 6) return cleaned;
  if (cleaned.length === 4) return cleaned + '01';
  return '';
}

function logBillingState(stage, extra) {
  let snapshot = billingState;
  try {
    snapshot = JSON.parse(JSON.stringify(billingState));
    console.log('[billingState][' + stage + ']', snapshot, extra || '');
  } catch (err) {
    console.log('[billingState][' + stage + '] (serialization failed)', err, billingState, extra || '');
  }

  try {
    const debugEl = qs('billingDebug');
    if (debugEl) {
      const resultLength = snapshot && snapshot.result && Array.isArray(snapshot.result.billingJson)
        ? snapshot.result.billingJson.length
        : 0;
      const preparedLength = snapshot && snapshot.prepared && Array.isArray(snapshot.prepared.billingJson)
        ? snapshot.prepared.billingJson.length
        : 0;
      const extraText = extra ? JSON.stringify(extra) : '';
      const lines = [
        `[${new Date().toISOString()}] stage: ${stage}`,
        `  result rows: ${resultLength}`,
        `  prepared rows: ${preparedLength}`,
        `  loading: ${!!snapshot.loading}`,
        `  status: ${snapshot.statusMessage || ''}`,
        `  extra: ${extraText}`
      ];
      debugEl.textContent += (debugEl.textContent ? '\n' : '') + lines.join('\n') + '\n';
    }
  } catch (err) {
    console.log('[billingState][' + stage + '] (ui log failed)', err);
  }
}

function setBillingLoading(flag, message) {
  billingState.loading = !!flag;
  billingState.statusMessage = flag ? (message || '生成中…') : '';
  logBillingState('setBillingLoading', { message: billingState.statusMessage });
  renderBillingResult();
}

function normalizeEditNumber(value) {
  return normalizeMoneyNumber(value);
}

function normalizeMoneyNumber(value) {
  if (typeof value === 'number') {
    return Number.isFinite(value) ? value : 0;
  }
  const text = String(value || '')
    .normalize('NFKC')
    .replace(/[，,]/g, '')
    .trim();
  if (!text) return 0;
  const num = Number(text);
  return Number.isFinite(num) ? num : 0;
}

function normalizeVisitCount(value) {
  if (typeof value === 'number') {
    return Number.isFinite(value) && value > 0 ? value : 0;
  }
  const normalized = String(value || '')
    .normalize('NFKC')
    .replace(/[，,]/g, '')
    .trim();
  const num = Number(normalized);
  return Number.isFinite(num) && num > 0 ? num : 0;
}

function normalizeBurdenRateInt(value) {
  if (value == null || value === '') return 0;
  const num = Number(value);
  if (Number.isFinite(num)) {
    if (num > 0 && num < 1) return Math.round(num * 10);
    if (num >= 1 && num < 10) return Math.round(num);
    if (num >= 10 && num <= 100) return Math.round(num / 10);
  }

  const normalized = String(value).normalize('NFKC').replace(/\s+/g, '').replace('％', '%');
  const withoutUnits = normalized.replace(/割|分/g, '').replace('%', '');
  const parsed = Number(withoutUnits);
  if (!Number.isFinite(parsed)) return 0;
  if (normalized.indexOf('%') >= 0) return Math.round(parsed / 10);
  if (parsed > 0 && parsed < 10) return Math.round(parsed);
  if (parsed >= 10 && parsed <= 100) return Math.round(parsed / 10);
  return 0;
}

function normalizeBurdenRateDisplay(value) {
  if (value === '自費') return '自費';
  const num = normalizeBurdenRateInt(value);
  if (!Number.isFinite(num) || num <= 0) return '';
  return num + '割';
}

function normalizeMedicalAssistanceFlag(value) {
  if (value === true) return true;
  if (value === false) return false;
  const num = Number(value);
  if (Number.isFinite(num)) return !!num;
  const text = String(value || '').trim().toLowerCase();
  if (!text) return false;
  return ['1', 'true', 'yes', 'y', 'on', '有', 'あり', '〇', '○', '◯'].includes(text);
}

function isDeprecatedInsuranceType(value) {
  if (!value) return false;
  return BILLING_DEPRECATED_INSURANCE_TYPES.includes(String(value).trim());
}

function resolveFrontEndUnitPrice(insuranceType, burdenRate, customUnitPrice, medicalAssistance) {
  const type = String(insuranceType || '').trim();
  const manualUnitPrice = normalizeMoneyNumber(customUnitPrice);
  const hasManualUnitPrice = Number.isFinite(manualUnitPrice) && manualUnitPrice !== 0;
  const isMedicalAssistance = normalizeMedicalAssistanceFlag(medicalAssistance);
  if ((type === '生保' || isMedicalAssistance) && !hasManualUnitPrice) return 0;
  if (isDeprecatedInsuranceType(type)) return 0;
  if (hasManualUnitPrice) return manualUnitPrice;
  if (type === '自費') return 0;
  return BILLING_UNIT_PRICE;
}

function recalculateBillingRow(row) {
  const visits = normalizeVisitCount(row.visitCount);
  const normalizedBurden = row.burdenRate === '自費' ? '自費' : normalizeBurdenRateInt(row.burdenRate);
  const normalizedUnitPrice = normalizeMoneyNumber(row.unitPrice);
  const unitPrice = resolveFrontEndUnitPrice(row.insuranceType, normalizedBurden, normalizedUnitPrice, row.medicalAssistance);
  const manualUnitPrice = normalizeMoneyNumber(row.unitPrice);
  const hasManualUnitPrice = Number.isFinite(manualUnitPrice) && manualUnitPrice !== 0;
  const isMedicalAssistance = normalizeMedicalAssistanceFlag(row.medicalAssistance);
  const shouldZeroByAssistance = (row.insuranceType === '生保' || isMedicalAssistance) && !hasManualUnitPrice;
  const isZeroCharge = shouldZeroByAssistance || (row.insuranceType === '自費' && !hasManualUnitPrice);
  const isMassage = isDeprecatedInsuranceType(row.insuranceType);
  const treatmentAmount = visits > 0 && !isMassage && !isZeroCharge ? unitPrice * visits : 0;
  const transportAmount = visits > 0 && !isMassage && !isZeroCharge ? BILLING_TRANSPORT_UNIT_PRICE * visits : 0;
  const carryOverAmount = normalizeMoneyNumber(row.carryOverAmount);
  const grandTotal = treatmentAmount + transportAmount + carryOverAmount;
  return Object.assign({}, row, {
    burdenRate: normalizedBurden,
    unitPrice,
    treatmentAmount,
    transportAmount,
    carryOverAmount,
    grandTotal
  });
}

function getBillingBaseUrl() {
  return (window.APP_CONFIG && window.APP_CONFIG.baseUrl) || '';
}

function getMergedBillingRows() {
  const baseRows = Array.isArray(billingState.result && billingState.result.billingJson)
    ? billingState.result.billingJson
    : [];
  return baseRows.map(row => {
    try {
      const baseRow = row && typeof row === 'object' ? row : {};
      const edits = billingState.edits[baseRow.patientId] || {};
      const merged = Object.assign({}, baseRow, edits);
      return recalculateBillingRow(merged);
    } catch (err) {
      console.error('Failed to merge billing row', err, row);
      return null;
    }
  }).filter(Boolean);
}

function getResponsibleDisplay(item) {
  if (!item) return '';
  if (item.responsibleName) return item.responsibleName;
  if (Array.isArray(item.responsibleNames) && item.responsibleNames.length) {
    return item.responsibleNames.join('・');
  }
  return item.responsibleEmail || '';
}

function resolveBurdenSortValue(value) {
  if (value === '自費') return 99;
  const num = Number(value);
  if (Number.isFinite(num)) return num;
  return 0;
}

function resolveBillingSortValue(row, field) {
  switch (field) {
    case 'nameKanji':
      return row.nameKanji || '';
    case 'insuranceType':
      return row.insuranceType || '';
    case 'burdenRate':
      return resolveBurdenSortValue(row.burdenRate);
    case 'unitPrice':
      return Number(row.unitPrice) || 0;
    case 'visitCount':
      return Number(row.visitCount) || 0;
    case 'treatmentAmount':
      return Number(row.treatmentAmount) || 0;
    case 'transportAmount':
      return Number(row.transportAmount) || 0;
    case 'carryOverAmount':
      return Number(row.carryOverAmount) || 0;
    case 'grandTotal':
      return Number(row.grandTotal) || 0;
    case 'responsible':
      return getResponsibleDisplay(row);
    case 'patientId':
      return row.patientId || '';
    default:
      return null;
  }
}

function sortBillingRows(rows) {
  const sort = billingState.sort || {};
  if (!sort.field || !Array.isArray(rows)) return rows || [];
  const dir = sort.direction === 'desc' ? -1 : 1;
  return rows.slice().sort((a, b) => {
    const va = resolveBillingSortValue(a, sort.field);
    const vb = resolveBillingSortValue(b, sort.field);
    if (va == null && vb == null) return 0;
    if (va == null) return 1;
    if (vb == null) return -1;
    if (typeof va === 'number' && typeof vb === 'number') {
      return (va - vb) * dir;
    }
    return String(va).localeCompare(String(vb), 'ja') * dir;
  });
}

function getDisplayBillingRows() {
  const merged = getMergedBillingRows();
  return sortBillingRows(merged);
}

function calculateBillingSummary(rows) {
  return (rows || []).reduce((acc, row) => {
    if (!row || typeof row !== 'object') return acc;
    acc.totalVisits += Number(row.visitCount) || 0;
    acc.totalGrandTotal += Number(row.grandTotal) || 0;
    return acc;
  }, { totalVisits: 0, totalGrandTotal: 0 });
}

function toggleBillingSort(field) {
  if (!field) return;
  const current = billingState.sort || {};
  if (current.field === field) {
    billingState.sort = { field, direction: current.direction === 'asc' ? 'desc' : 'asc' };
  } else {
    billingState.sort = { field, direction: 'asc' };
  }
  renderBillingResult();
}

function commitBillingEdit(patientId, field, value) {
  const pid = String(patientId || '').trim();
  if (!pid) return;
  billingState.edits[pid] = Object.assign({}, billingState.edits[pid] || {}, { [field]: value });
  billingState.editing = null;
  renderBillingResult();
}

function startBillingEdit(patientId, field) {
  billingState.editing = { patientId, field };
  renderBillingResult();
}

function ensureBillingRoute() {
  // Routing is managed in-memory to avoid sandboxed URL mutations that raise SecurityError.
  if (typeof window !== 'undefined') {
    window.APP_CONFIG = Object.assign({}, window.APP_CONFIG, { view: 'billing' });
  }
}

function loadBillingPage() {
  initBillingPage();
}

function normalizeBillingResultPayload(raw) {
  if (!raw) return null;

  function parseMaybeJson(value) {
    if (typeof value !== 'string') return value;
    try {
      return JSON.parse(value);
    } catch (err) {
      const msg = err && err.message ? err.message : err;
      console.warn('Failed to parse billing payload text:', msg);
      return null;
    }
  }

  function coerceBillingJson(value) {
    if (Array.isArray(value)) return value;
    if (typeof value === 'string') {
      try {
        const parsed = JSON.parse(value);
        return Array.isArray(parsed) ? parsed : null;
      } catch (err) {
        const msg = err && err.message ? err.message : err;
        console.warn('Failed to parse billingJson string:', msg);
        return null;
      }
    }
    return null;
  }

  function findBillingPayload(root, metaSource) {
    const queue = [];
    const visited = new WeakSet();

    function extractMetaFields(source) {
      if (!source || typeof source !== 'object') return {};
      const meta = {};
      Object.keys(source).forEach(key => {
        const value = source[key];
        const type = typeof value;
        if (
          value === null ||
          type === 'string' ||
          type === 'number' ||
          type === 'boolean' ||
          Object.prototype.toString.call(value) === '[object Date]'
        ) {
          meta[key] = value;
        }
      });
      return meta;
    }

    function mergeWithMeta(obj, meta) {
      const billingJson = coerceBillingJson(obj.billingJson);
      if (!billingJson) return null;
      return Object.assign({}, meta, obj, { billingJson });
    }

    function enqueue(candidate, inheritedMeta) {
      const parsed = parseMaybeJson(candidate);
      const value = parsed === null ? candidate : parsed;
      if (value && typeof value === 'object' && !visited.has(value)) {
        visited.add(value);
        const meta = Object.assign({}, inheritedMeta, extractMetaFields(value));
        queue.push({ obj: value, meta });
      }
    }

    const initialMeta = extractMetaFields(metaSource);
    enqueue(root, initialMeta);

    while (queue.length) {
      const { obj, meta } = queue.shift();
      const merged = mergeWithMeta(obj, meta);
      if (merged) {
        return merged;
      }

      Object.keys(obj).forEach(key => {
        const value = obj[key];
        enqueue(value, meta);
      });
    }

    return null;
  }

  let result = parseMaybeJson(raw);
  if (result == null) return null;

  if (Array.isArray(result)) {
    return { billingJson: result, billingMonth: '', preparedAt: null };
  }

  const found = findBillingPayload(result, result);
  if (found && found.billingJson) {
    return found;
  }

  const billingJson = coerceBillingJson(result.billingJson) || [];
  if (!billingJson.length) {
    console.warn('[billing] billingJson not found in payload; returning empty array');
  }
  return Object.assign({}, result, { billingJson });
}

function handleBillingAggregation() {
  const ym = normalizeYm(qs('billingMonth').value);
  if (!ym) {
    alert('請求月を入力してください (YYYY-MM)');
    return;
  }
  logBillingState('handleBillingAggregation:start', { ym });
  setBillingLoading(true, '集計中…');
  google.script.run
    .withSuccessHandler(function(result) {
      logBillingState('prepareBillingData:success', { ym });
      onBillingPrepared(result);
    })
    .withFailureHandler(function(err) {
      logBillingState('prepareBillingData:error', { ym, error: err && err.message ? err.message : err });
      onBillingFailed(err);
    })
    .prepareBillingData(ym);
}

function onBillingPrepared(result) {
  console.warn('[billing-debug] raw result = ', JSON.stringify(result, null, 2).slice(0, 5000));
  const normalized = normalizeBillingResultPayload(result);
  billingState.result = normalized;
  billingState.prepared = normalized;
  billingState.loading = false;
  billingState.statusMessage = '集計が完了しました。内容確認後にPDFを生成してください。';
  billingState.edits = {};
  billingState.editing = null;
  logBillingState('onBillingPrepared', { rows: normalized && normalized.billingJson ? normalized.billingJson.length : 0 });
  renderBillingResult();
}

function handleBillingPdfGeneration() {
  if (!billingState.prepared || !billingState.prepared.billingMonth) {
    alert('先に「請求データを集計」を実行してください。');
    return;
  }
  setBillingLoading(true, 'PDF生成中…');
  google.script.run
    .withSuccessHandler(onBillingPdfCompleted)
    .withFailureHandler(onBillingFailed)
    .applyBillingEditsAndGenerateInvoices(billingState.prepared.billingMonth, {
      edits: Object.keys(billingState.edits || {}).map(pid => Object.assign({ patientId: pid }, billingState.edits[pid]))
    });
}

function onBillingPdfCompleted(result) {
  const normalized = normalizeBillingResultPayload(result) || billingState.prepared || null;
  billingState.result = normalized;
  billingState.prepared = normalized;
  billingState.loading = false;
  billingState.statusMessage = 'PDF生成と担当者フォルダへの保存が完了しました';
  billingState.edits = {};
  billingState.editing = null;
  logBillingState('onBillingPdfCompleted', { rows: normalized && normalized.billingJson ? normalized.billingJson.length : 0 });
  renderBillingResult();
}

function handleBankExport() {
  if (!billingState.prepared || !billingState.prepared.billingMonth) {
    alert('先に「請求データを集計」を実行してください。');
    return;
  }
  setBillingLoading(true, '銀行データ出力中…');
  google.script.run
    .withSuccessHandler(onBankExportCompleted)
    .withFailureHandler(onBillingFailed)
    .generateBankTransferDataFromCache(billingState.prepared.billingMonth, {});
}

function onBankExportCompleted(result) {
  billingState.loading = false;
  billingState.statusMessage = '銀行データを出力しました' + (result && result.inserted ? `（${result.inserted}件）` : '');
  logBillingState('onBankExportCompleted');
  renderBillingResult();
}

function handleBillingSaveEdits() {
  if (!billingState.prepared || !billingState.prepared.billingMonth) {
    alert('先に「請求データを集計」を実行してください。');
    return;
  }
  setBillingLoading(true, '保存中…');
  google.script.run
    .withSuccessHandler(onBillingSaveCompleted)
    .withFailureHandler(onBillingFailed)
    .applyBillingEdits(billingState.prepared.billingMonth, {
      edits: Object.keys(billingState.edits || {}).map(pid => Object.assign({ patientId: pid }, billingState.edits[pid]))
    });
}

function onBillingSaveCompleted(result) {
  billingState.result = result || billingState.result;
  billingState.prepared = result || billingState.prepared;
  billingState.loading = false;
  billingState.statusMessage = '保存が完了しました';
  billingState.edits = {};
  billingState.editing = null;
  logBillingState('onBillingSaveCompleted', { rows: billingState.prepared && billingState.prepared.billingJson ? billingState.prepared.billingJson.length : 0 });
  renderBillingResult();
}

function onBillingFailed(err) {
  console.error('[billing generation failed]', err);
  const msg = err && err.message ? err.message : String(err);
  billingState.loading = false;
  billingState.statusMessage = '請求処理に失敗しました';
  logBillingState('onBillingFailed', { error: msg });
  renderBillingResult();
  alert('請求生成に失敗しました: ' + msg);
}

function formatCurrency(value) {
  const num = Number(value);
  if (!Number.isFinite(num)) return '-';
  return num.toLocaleString('ja-JP') + ' 円';
}

function renderBillingStatus(result) {
  const el = qs('billingStatus');
  if (!el) return;
  if (billingState.loading) {
    el.innerHTML = `<span class="loading"><span class="spinner"></span>${billingState.statusMessage || '生成中…'}</span>`;
    return;
  }
  if (billingState.statusMessage) {
    el.textContent = billingState.statusMessage;
    return;
  }
  if (billingState.prepared) {
    el.textContent = result && result.files && result.files.length
      ? 'PDF生成が完了しました'
      : '集計済み（PDF未生成）';
    return;
  }
  el.textContent = '';
}

function renderDownloads(result) {
  const box = qs('downloads');
  if (!box) return;
  box.innerHTML = '';
  if (billingState.loading) {
    box.innerHTML = `<div class="loading"><span class="spinner"></span>ファイル生成中…</div>`;
    return;
  }
  const files = (result && Array.isArray(result.files)) ? result.files.filter(file => file && file.url) : [];
  if (!files.length) {
    box.innerHTML = billingState.prepared
      ? '<div class="muted">集計済みです。PDF生成ボタンを押してください。</div>'
      : '<div class="muted">出力ファイルはまだありません。</div>';
    return;
  }
  box.innerHTML = files.map(link => `
    <a class="download-link" href="${link.url}" target="_blank" rel="noopener">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <path d="M12 3v14" /><path d="M5 10l7 7 7-7" /><path d="M5 21h14" />
      </svg>
      <div>
        <div>${link.name || '請求書PDF'}</div>
        <small class="muted" style="display:block;">${link.nameKanji || link.patientId || ''}</small>
      </div>
    </a>`).join('');
}

function renderMonthBadge(result) {
  const label = qs('billingMonthLabel');
  if (!label) return;
  if (result && result.billingMonth) {
    label.style.display = 'inline-flex';
    label.textContent = '請求月: ' + result.billingMonth;
  } else {
    label.style.display = 'none';
    label.textContent = '';
  }
}

function renderBillingSummary(rows) {
  const box = qs('billingSummary');
  if (!box) return;
  if (!rows || !rows.length) {
    box.style.display = 'none';
    box.innerHTML = '';
    return;
  }
  const summary = calculateBillingSummary(rows);
  box.style.display = '';
  box.innerHTML = `
    <div class="summary-card">
      <p class="summary-label">総施術回数</p>
      <p class="summary-value">${summary.totalVisits.toLocaleString()} 回</p>
    </div>
    <div class="summary-card">
      <p class="summary-label">請求合計金額</p>
      <p class="summary-value">${formatCurrency(summary.totalGrandTotal)}</p>
    </div>
  `;
}

function renderBillingResult() {
  logBillingState('renderBillingResult', {
    resultLength: billingState.result && billingState.result.billingJson ? billingState.result.billingJson.length : 0,
    preparedLength: billingState.prepared && billingState.prepared.billingJson ? billingState.prepared.billingJson.length : 0
  });
  updateBillingControls();
  const box = qs('billingResult');
  if (!box) return;
  const result = billingState.result;
  renderBillingStatus(result);
  renderDownloads(result);
  renderMonthBadge(result);
  renderBillingSummary(null);

  if (billingState.loading) {
    box.innerHTML = '<div class="loading"><span class="spinner"></span>請求データを生成中です…</div>';
    return;
  }
  if (!result || !result.billingJson || !result.billingJson.length) {
    renderBillingSummary(null);
    box.innerHTML = '<div class="muted">まだ請求を生成していません。</div>';
    return;
  }

  const rows = getDisplayBillingRows();
  renderBillingSummary(rows);
  const header = [
    { key: 'patientId', label: '患者ID', sortable: true },
    { key: 'nameKanji', label: '氏名', sortable: true },
    { key: 'responsible', label: '担当者', sortable: true },
    { key: 'insuranceType', label: '保険種別', sortable: true },
    { key: 'medicalAssistance', label: '医療助成', sortable: false },
    { key: 'payerType', label: '保険者', sortable: false },
    { key: 'burdenRate', label: '負担', sortable: true },
    { key: 'visitCount', label: '回数', sortable: true },
    { key: 'unitPrice', label: '単価', sortable: true },
    { key: 'treatmentAmount', label: '施術料', sortable: true },
    { key: 'transportAmount', label: '交通費', sortable: true },
    { key: 'carryOverAmount', label: '繰越', sortable: true },
    { key: 'grandTotal', label: '合計', sortable: true }
  ];

  function renderSortHeaderCell(h) {
    if (!h.sortable) {
      return `<th>${h.label}</th>`;
    }
    const active = billingState.sort && billingState.sort.field === h.key;
    const indicator = active ? (billingState.sort.direction === 'asc' ? '▲' : '▼') : '';
    const thClass = h.sortable ? 'sortable' : '';
    return `<th class="${thClass}"><button type="button" class="sort-header" data-sort-key="${h.key}">${h.label}${indicator ? `<span class="sort-indicator">${indicator}</span>` : ''}</button></th>`;
  }

  function renderEditableCell(item, field, alignRight) {
    const editing = billingState.editing && billingState.editing.patientId === item.patientId && billingState.editing.field === field;
    const baseAttrs = `data-edit-field="${field}" data-edit-patient="${item.patientId}"`;
    const editClass = alignRight ? 'cell-edit inline-editor right' : 'cell-edit inline-editor';
    const viewClass = alignRight ? 'cell-edit right' : 'cell-edit';
    if (editing) {
      if (field === 'insuranceType') {
        const needsUpdate = isDeprecatedInsuranceType(item.insuranceType);
        const options = BILLING_INSURANCE_OPTIONS.map(opt => `<option value="${opt}" ${opt === item.insuranceType ? 'selected' : ''}>${opt}</option>`).join('');
        const select = `<select class="${editClass}" ${baseAttrs}>${needsUpdate ? '<option value="" disabled selected>保険種別を選択</option>' : ''}${options}</select>`;
        if (needsUpdate) {
          return `<div class="insurance-editor">${select}<div class="field-note warn">以前の「マッサージ」種別が設定されています。現在の保険種別を選び直してください。</div></div>`;
        }
        return select;
      }
      if (field === 'burdenRate') {
        return `<select class="${editClass}" ${baseAttrs}>${BILLING_BURDEN_OPTIONS.map(opt => `<option value="${opt.value}" ${String(opt.value) === String(item.burdenRate) ? 'selected' : ''}>${opt.label}</option>`).join('')}</select>`;
      }
      if (field === 'payerType') {
        return `<select class="${editClass}" ${baseAttrs}>${BILLING_PAYER_OPTIONS.map(opt => `<option value="${opt}" ${opt === item.payerType ? 'selected' : ''}>${opt}</option>`).join('')}</select>`;
      }
      if (field === 'medicalAssistance') {
        const checked = normalizeMedicalAssistanceFlag(item.medicalAssistance) ? 'checked' : '';
        return `<label class="${editClass}" style="display:flex;align-items:center;gap:6px;"><input type="checkbox" ${baseAttrs} ${checked} />医療助成</label>`;
      }
      if (field === 'unitPrice' || field === 'carryOverAmount') {
        const val = normalizeEditNumber(item[field]);
        return `<input class="${editClass}" ${baseAttrs} type="number" step="10" value="${val}" />`;
      }
    }

    const display = (() => {
      switch (field) {
        case 'insuranceType':
          if (isDeprecatedInsuranceType(item.insuranceType)) return '要修正: マッサージ';
          return item.insuranceType || '編集';
        case 'medicalAssistance':
          return normalizeMedicalAssistanceFlag(item.medicalAssistance) ? '有' : 'なし';
        case 'burdenRate':
          return normalizeBurdenRateDisplay(item.burdenRate) || '編集';
        case 'payerType':
          return item.payerType || '編集';
        case 'unitPrice':
          return formatCurrency(item.unitPrice);
        case 'carryOverAmount':
          return formatCurrency(item.carryOverAmount);
        default:
          return item[field] || '';
      }
    })();
    return `<button type="button" class="${viewClass}" ${baseAttrs} aria-label="${field} を編集">${display}</button>`;
  }

  const legacyRows = rows.filter(row => isDeprecatedInsuranceType(row.insuranceType));
  const notices = [];
  if (legacyRows.length) {
    const sample = legacyRows.slice(0, 3).map(r => (r.nameKanji || r.patientId || '不明')).join('／');
    const overflow = legacyRows.length > 3 ? `、ほか ${legacyRows.length - 3} 名` : '';
    notices.push(`<div class="alert warn">「マッサージ」保険種別は廃止されました。${sample}${overflow} に古い種別が残っています。保険種別を選び直してください。</div>`);
  }

  const bodyRows = [];
  rows.forEach(item => {
    try {
      const safeItem = item && typeof item === 'object' ? item : {};
      bodyRows.push(`
      <tr>
        <td>${safeItem.patientId || ''}</td>
        <td>${safeItem.nameKanji || ''}</td>
        <td>${getResponsibleDisplay(safeItem) || '—'}</td>
        <td>${renderEditableCell(safeItem, 'insuranceType')}</td>
        <td>${renderEditableCell(safeItem, 'medicalAssistance')}</td>
        <td>${renderEditableCell(safeItem, 'payerType')}</td>
        <td>${renderEditableCell(safeItem, 'burdenRate')}</td>
        <td>${safeItem.visitCount || 0}</td>
        <td class="right">${renderEditableCell(safeItem, 'unitPrice', true)}</td>
        <td class="right">${formatCurrency(safeItem.treatmentAmount)}</td>
        <td class="right">${formatCurrency(safeItem.transportAmount)}</td>
        <td class="right">${renderEditableCell(safeItem, 'carryOverAmount', true)}</td>
        <td class="right">${formatCurrency(safeItem.grandTotal)}</td>
      </tr>`);
    } catch (err) {
      console.error('Failed to render billing row', err, item);
      const pid = item && item.patientId ? `患者ID: ${item.patientId}` : '患者行の表示でエラーが発生しました';
      bodyRows.push(`<tr class="error-row"><td colspan="13">${pid}</td></tr>`);
    }
  });

  const tableHtml = [
    ...notices,
    '<table><thead><tr>',
    header.map(renderSortHeaderCell).join(''),
    '</tr></thead><tbody>',
    ...bodyRows,
    '</tbody></table>',
    renderBillingActionFooter(rows && rows.length > 0)
  ].join('');

  box.innerHTML = tableHtml;
  attachBillingEditHandlers();
  attachBillingSortHandlers();
}

function renderBillingActionFooter(hasRows) {
  if (!hasRows) return '';
  const prepared = !!(billingState.prepared && billingState.prepared.billingMonth);
  const loading = billingState.loading;
  const saveDisabled = loading || !prepared;
  const pdfDisabled = loading || !prepared;
  const helper = prepared
    ? '編集を保存したら、そのままPDF生成へ進めます。'
    : '先に「請求データを集計」を実行すると保存・PDF生成が有効になります。';
  return `
    <div class="action-footer">
      <div>
        <div class="muted">${helper}</div>
      </div>
      <div class="action-buttons">
        <button class="btn secondary" type="button" onclick="handleBillingSaveEdits()" ${saveDisabled ? 'disabled' : ''}>変更を保存</button>
        <button class="btn" type="button" onclick="handleBillingPdfGeneration()" ${pdfDisabled ? 'disabled' : ''}>PDF生成＆担当者フォルダ保存</button>
      </div>
    </div>`;
}

function attachBillingEditHandlers() {
  const box = qs('billingResult');
  if (!box) return;
  box.querySelectorAll('button.cell-edit').forEach(btn => {
    btn.onclick = function () {
      const pid = this.getAttribute('data-edit-patient');
      const field = this.getAttribute('data-edit-field');
      startBillingEdit(pid, field);
    };
  });
  box.querySelectorAll('select.inline-editor, input.inline-editor').forEach(input => {
    input.onchange = function () {
      const pid = this.getAttribute('data-edit-patient');
      const field = this.getAttribute('data-edit-field');
      let value = this.value;
      if (this.type === 'checkbox') {
        value = normalizeMedicalAssistanceFlag(this.checked);
      }
      if (field === 'burdenRate') {
        value = value === '自費' ? '自費' : normalizeBurdenRateInt(value);
      }
      if (field === 'unitPrice' || field === 'carryOverAmount') {
        value = normalizeMoneyNumber(value);
      }
      if (field === 'visitCount') {
        value = normalizeVisitCount(value);
      }
      commitBillingEdit(pid, field, value);
    };
    input.onblur = input.onchange;
  });
}

function attachBillingSortHandlers() {
  const box = qs('billingResult');
  if (!box) return;
  box.querySelectorAll('button.sort-header').forEach(btn => {
    btn.onclick = function () {
      const field = this.getAttribute('data-sort-key');
      toggleBillingSort(field);
    };
  });
}

function initBillingPage() {
  ensureBillingRoute();
  const input = qs('billingMonth');
  if (input && !input.value) {
    input.value = getDefaultMonth();
  }
  updateBillingControls();
  renderBillingResult();
}

(function bootstrap() {
  const body = document.body;
  if (body && body.dataset) {
    window.APP_CONFIG = Object.assign({}, window.APP_CONFIG, {
      view: body.dataset.view || (window.APP_CONFIG && window.APP_CONFIG.view) || '',
      baseUrl: body.dataset.baseUrl || (window.APP_CONFIG && window.APP_CONFIG.baseUrl) || ''
    });
  }

  const view = (window.APP_CONFIG && window.APP_CONFIG.view) || '';
  if (view === 'billing') {
    initBillingPage();
  }
})();

const billingGlobal = typeof window !== 'undefined' ? window : null;
if (billingGlobal) {
  billingGlobal.loadBillingPage = loadBillingPage;
  billingGlobal.handleBillingAggregation = handleBillingAggregation;
  billingGlobal.handleBillingPdfGeneration = handleBillingPdfGeneration;
  billingGlobal.handleBillingSaveEdits = handleBillingSaveEdits;
  billingGlobal.handleBankExport = handleBankExport;
}
</script>
