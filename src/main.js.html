<script>
const billingState = {
  loading: false,
  result: null,
  prepared: null,
  statusMessage: '',
  errorMessage: '',
  edits: {},
  patientInfoEdits: {},
  billingOverrideEdits: {},
  previewTotals: {},
  editing: null,
  sort: { field: null, direction: 'asc' }
};

const BILLING_BURDEN_OPTIONS = [
  { value: 1, label: '1割' },
  { value: 2, label: '2割' },
  { value: 3, label: '3割' },
  { value: '自費', label: '自費' }
];
const BILLING_PAYER_OPTIONS = ['保険', '自費'];
const BILLING_TREATMENT_PRICE = 4070;
const BILLING_ELECTRO_PRICE = 100;
const BILLING_UNIT_PRICE = BILLING_TREATMENT_PRICE + BILLING_ELECTRO_PRICE;
const BILLING_TRANSPORT_UNIT_PRICE_FALLBACK = 33;
const BILLING_TRANSPORT_UNIT_PRICE = (typeof globalThis !== 'undefined' && typeof globalThis.BILLING_TRANSPORT_UNIT_PRICE === 'number')
  ? globalThis.BILLING_TRANSPORT_UNIT_PRICE
  : BILLING_TRANSPORT_UNIT_PRICE_FALLBACK;
const BILLING_PATIENT_INFO_FIELDS = ['medicalAssistance', 'burdenRate', 'payerType', 'responsible', 'bankInfo', 'isNew'];
const BILLING_BILLING_OVERRIDES_FIELDS = ['unitPrice', 'transportAmount', 'carryOverAmount', 'visitCount', 'selfPayAmount'];
const BILLING_OVERRIDE_BADGE_FIELDS = ['unitPrice', 'transportAmount', 'carryOverAmount', 'visitCount', 'selfPayAmount', 'burdenRate'];

function qs(id) {
  return document.getElementById(id);
}

function escapeHtml(text) {
  return String(text || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function getDefaultMonth() {
  const today = new Date();
  const prevMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1);
  const y = prevMonth.getFullYear();
  const m = String(prevMonth.getMonth() + 1).padStart(2, '0');
  return y + '-' + m;
}

function updateBillingControls() {
  const monthInput = qs('billingMonth');
  const aggregateBtn = qs('billingAggregateBtn');
  const pdfBtn = qs('billingPdfBtn');
  const saveBtn = qs('billingSaveBtn');
  const bankBtn = qs('billingBankBtn');
  const loading = billingState.loading;
  const prepared = !!(billingState.prepared && billingState.prepared.billingMonth);

  if (monthInput) {
    monthInput.disabled = loading;
  }
  if (aggregateBtn) {
    aggregateBtn.disabled = loading;
    aggregateBtn.setAttribute('aria-busy', loading ? 'true' : 'false');
  }
  if (pdfBtn) {
    const disabled = loading || !prepared;
    pdfBtn.disabled = disabled;
    pdfBtn.setAttribute('aria-busy', loading ? 'true' : 'false');
    pdfBtn.title = disabled && !prepared ? '先に「請求データを集計」を実行してください' : '';
  }
  if (saveBtn) {
    const disabled = loading || !prepared;
    saveBtn.disabled = disabled;
    saveBtn.setAttribute('aria-busy', loading ? 'true' : 'false');
    saveBtn.title = disabled && !prepared ? '先に「請求データを集計」を実行してください' : '';
  }
  if (bankBtn) {
    const disabled = loading || !prepared;
    bankBtn.disabled = disabled;
    bankBtn.setAttribute('aria-busy', loading ? 'true' : 'false');
    bankBtn.title = disabled && !prepared ? '先に「請求データを集計」を実行してください' : '';
  }
}

function normalizeYm(raw) {
  if (!raw) return '';
  const cleaned = String(raw).replace(/[^0-9]/g, '');
  if (cleaned.length === 6) return cleaned;
  if (cleaned.length === 4) return cleaned + '01';
  return '';
}

function logBillingState(stage, extra) {
  let snapshot = billingState;
  try {
    snapshot = JSON.parse(JSON.stringify(billingState));
    console.log('[billingState][' + stage + ']', snapshot, extra || '');
  } catch (err) {
    console.log('[billingState][' + stage + '] (serialization failed)', err, billingState, extra || '');
  }

  try {
    const debugEl = qs('billingDebug');
    if (debugEl) {
      const resultLength = snapshot && snapshot.result && Array.isArray(snapshot.result.billingJson)
        ? snapshot.result.billingJson.length
        : 0;
      const preparedLength = snapshot && snapshot.prepared && Array.isArray(snapshot.prepared.billingJson)
        ? snapshot.prepared.billingJson.length
        : 0;
      const extraText = extra ? JSON.stringify(extra) : '';
      const lines = [
        `[${new Date().toISOString()}] stage: ${stage}`,
        `  result rows: ${resultLength}`,
        `  prepared rows: ${preparedLength}`,
        `  loading: ${!!snapshot.loading}`,
        `  status: ${snapshot.statusMessage || ''}`,
        `  extra: ${extraText}`
      ];
      debugEl.textContent += (debugEl.textContent ? '\n' : '') + lines.join('\n') + '\n';
    }
  } catch (err) {
    console.log('[billingState][' + stage + '] (ui log failed)', err);
  }
}

function setBillingLoading(flag, message) {
  billingState.loading = !!flag;
  billingState.statusMessage = flag ? (message || '生成中…') : '';
  if (flag) {
    billingState.errorMessage = '';
  }
  logBillingState('setBillingLoading', { message: billingState.statusMessage });
  renderBillingResult();
}

function setBillingError(message, err) {
  const detail = err && err.message ? err.message : (err != null ? String(err) : '');
  const combined = detail && message ? `${message}: ${detail}` : (message || detail || '不明なエラー');
  billingState.errorMessage = combined;
  logBillingState('billingError', { message: combined });
  renderBillingResult();
}

function normalizeEditNumber(value) {
  return normalizeMoneyNumber(value);
}

function normalizeMoneyNumber(value) {
  if (typeof value === 'number') {
    return Number.isFinite(value) ? value : 0;
  }
  const text = String(value || '')
    .normalize('NFKC')
    .replace(/[，,]/g, '')
    .trim();
  if (!text) return 0;
  const num = Number(text);
  return Number.isFinite(num) ? num : 0;
}

function roundToNearestTen(value) {
  const num = Number(value);
  if (!Number.isFinite(num)) return 0;
  return Math.round(num / 10) * 10;
}

function normalizeVisitCount(value) {
  if (typeof value === 'number') {
    return Number.isFinite(value) && value > 0 ? value : 0;
  }
  const normalized = String(value || '')
    .normalize('NFKC')
    .replace(/[，,]/g, '')
    .trim();
  const num = Number(normalized);
  return Number.isFinite(num) && num > 0 ? num : 0;
}

function normalizeBurdenRateInt(value) {
  if (value == null || value === '') return 0;
  if (String(value).trim() === '自費') return '自費';
  const num = Number(value);
  if (Number.isFinite(num)) {
    if (num > 0 && num < 1) return Math.round(num * 10);
    if (num >= 1 && num < 10) return Math.round(num);
    if (num >= 10 && num <= 100) return Math.round(num / 10);
  }

  const normalized = String(value).normalize('NFKC').replace(/\s+/g, '').replace('％', '%');
  const withoutUnits = normalized.replace(/割|分/g, '').replace('%', '');
  const parsed = Number(withoutUnits);
  if (!Number.isFinite(parsed)) return 0;
  if (normalized.indexOf('%') >= 0) return Math.round(parsed / 10);
  if (parsed > 0 && parsed < 10) return Math.round(parsed);
  if (parsed >= 10 && parsed <= 100) return Math.round(parsed / 10);
  return 0;
}

function normalizeBurdenRateDisplay(value) {
  if (value === '自費') return '自費';
  const num = normalizeBurdenRateInt(value);
  if (!Number.isFinite(num) || num <= 0) return '';
  return num + '割';
}

function normalizeMedicalAssistanceFlag(value) {
  if (value === 1 || value === '1' || value === true) return 1;
  return 0;
}

function getBillingBaseUrl() {
  return (window.APP_CONFIG && window.APP_CONFIG.baseUrl) || '';
}

function getBillingOverrideFlags() {
  const source = billingState.prepared || billingState.result || {};
  return (source && source.billingOverrideFlags) || {};
}

function shouldShowBillingOverrideBadge(field) {
  return BILLING_OVERRIDE_BADGE_FIELDS.indexOf(field) >= 0;
}

function hasBillingOverride(patientId, field) {
  if (!patientId || !shouldShowBillingOverrideBadge(field)) return false;
  const flags = getBillingOverrideFlags();
  const entry = flags && flags[patientId];
  return !!(entry && entry[field]);
}

function wrapWithOverrideBadge(content, patientId, field, alignRight) {
  if (!shouldShowBillingOverrideBadge(field) || !hasBillingOverride(patientId, field)) {
    return content;
  }
  const badge = '<span class="override-badge" title="月次編集されています">※上書き</span>';
  const klass = alignRight ? 'cell-badge right' : 'cell-badge';
  return `<div class="${klass}">${content}${badge}</div>`;
}

function getMergedBillingRows() {
  const baseRows = Array.isArray(billingState.result && billingState.result.billingJson)
    ? billingState.result.billingJson
    : [];
  return baseRows.map(row => {
    try {
      const baseRow = row && typeof row === 'object' ? row : {};
      const edits = billingState.edits[baseRow.patientId] || {};
      const calculated = (billingState.previewTotals && billingState.previewTotals[baseRow.patientId]) || {};
      return Object.assign({}, baseRow, edits, calculated);
    } catch (err) {
      console.error('Failed to merge billing row', err, row);
      return null;
    }
  }).filter(Boolean);
}

function getResponsibleDisplay(item) {
  if (!item) return '';
  if (item.responsibleName) return item.responsibleName;
  if (Array.isArray(item.responsibleNames) && item.responsibleNames.length) {
    return item.responsibleNames.join('・');
  }
  return item.responsibleEmail || '';
}

function formatPaidStatus(item) {
  if (!item) return '';
  return item.paidStatus || item.bankStatus || '';
}

function maskAccountNumber(value) {
  const digits = (value || '').replace(/\D/g, '');
  if (!digits) return '';
  const suffix = digits.slice(-4);
  return suffix ? `***${suffix}` : '';
}

function formatBankInfo(item) {
  if (!item) return '';
  const bankCode = item.bankCode || '';
  const branchCode = item.branchCode || '';
  const accountNumber = item.accountNumber || '';
  const codes = [bankCode, branchCode].filter(Boolean).join('-');
  const account = maskAccountNumber(accountNumber);
  return [codes, account ? `口:${account}` : ''].filter(Boolean).join(' / ');
}

function formatNewFlag(item) {
  if (!item || !item.isNew) return '';
  return '<span class="badge">新規</span>';
}

function resolvePatientIdSortValue(value) {
  const num = Number(value);
  if (Number.isFinite(num)) return num;
  const trimmed = String(value || '').trim();
  if (!trimmed) return 0;
  const fallback = Number(trimmed.replace(/[^0-9]/g, ''));
  return Number.isFinite(fallback) ? fallback : 0;
}

function resolveBurdenSortValue(value) {
  if (value === '自費') return 99;
  const num = Number(value);
  if (Number.isFinite(num)) return num;
  return 0;
}

function resolveBillingSortValue(row, field) {
  switch (field) {
    case 'nameKanji':
      return row.nameKanji || '';
    case 'burdenRate':
      return resolveBurdenSortValue(row.burdenRate);
    case 'unitPrice':
      return Number(row.unitPrice) || 0;
    case 'visitCount':
      return Number(row.visitCount) || 0;
    case 'treatmentAmount':
      return Number(row.treatmentAmount) || 0;
    case 'transportAmount':
      return Number(row.transportAmount) || 0;
    case 'carryOverAmount':
      return Number(row.carryOverAmount) || 0;
    case 'grandTotal':
      return Number(row.grandTotal) || 0;
    case 'responsible':
      return getResponsibleDisplay(row);
    case 'patientId':
      return resolvePatientIdSortValue(row.patientId);
    default:
      return null;
  }
}

function sortBillingRows(rows) {
  const sort = billingState.sort || {};
  if (!sort.field || !Array.isArray(rows)) return rows || [];
  const dir = sort.direction === 'desc' ? -1 : 1;
  return rows.slice().sort((a, b) => {
    const va = resolveBillingSortValue(a, sort.field);
    const vb = resolveBillingSortValue(b, sort.field);
    if (va == null && vb == null) return 0;
    if (va == null) return 1;
    if (vb == null) return -1;
    if (typeof va === 'number' && typeof vb === 'number') {
      return (va - vb) * dir;
    }
    return String(va).localeCompare(String(vb), 'ja') * dir;
  });
}

function getDisplayBillingRows() {
  const merged = getMergedBillingRows();
  return sortBillingRows(merged);
}

function calculateBillingSummary(rows) {
  return (rows || []).reduce((acc, row) => {
    if (!row || typeof row !== 'object') return acc;
    acc.totalVisits += Number(row.visitCount) || 0;
    acc.totalGrandTotal += Number(row.grandTotal) || 0;
    return acc;
  }, { totalVisits: 0, totalGrandTotal: 0 });
}

function toggleBillingSort(field) {
  if (!field) return;
  const current = billingState.sort || {};
  if (current.field === field) {
    billingState.sort = { field, direction: current.direction === 'asc' ? 'desc' : 'asc' };
  } else {
    billingState.sort = { field, direction: 'asc' };
  }
  renderBillingResult();
}

function calculateBillingRowTotalsLocal(row) {
  const source = row && typeof row === 'object' ? row : {};
  const insuranceType = source.insuranceType ? String(source.insuranceType).trim() : '';
  const burdenRate = normalizeBurdenRateInt(source.burdenRate);
  const visitCount = normalizeVisitCount(source.visitCount);
  const medicalAssistance = normalizeMedicalAssistanceFlag(source.medicalAssistance);
  const carryOverAmount = normalizeMoneyNumber(source.carryOverAmount)
    + normalizeMoneyNumber(source.carryOverFromHistory);

  const manualTransportInput = Object.prototype.hasOwnProperty.call(source, 'manualTransportAmount')
    ? source.manualTransportAmount
    : source.transportAmount;
  const normalizedManualTransport = (manualTransportInput === '' || manualTransportInput === null || manualTransportInput === undefined)
    ? null
    : normalizeMoneyNumber(manualTransportInput);
  const hasManualTransport = manualTransportInput !== ''
    && manualTransportInput !== null
    && manualTransportInput !== undefined
    && Number.isFinite(normalizedManualTransport);

  const manualUnitPriceInput = Object.prototype.hasOwnProperty.call(source, 'manualUnitPrice')
    ? source.manualUnitPrice
    : source.unitPrice;
  const normalizedManualUnitPrice = (manualUnitPriceInput === '' || manualUnitPriceInput === null)
    ? null
    : normalizeMoneyNumber(manualUnitPriceInput);
  const hasManualUnitPrice = manualUnitPriceInput !== ''
    && manualUnitPriceInput !== null
    && Number.isFinite(normalizedManualUnitPrice)
    && normalizedManualUnitPrice !== 0;

  const patientUnitPrice = normalizeMoneyNumber(source.unitPrice);
  const isSelfPaid = insuranceType === '自費' || burdenRate === '自費';

  let treatmentUnitPrice = 0;
  if (insuranceType === 'マッサージ') {
    treatmentUnitPrice = 0;
  } else if (hasManualUnitPrice) {
    treatmentUnitPrice = normalizedManualUnitPrice;
  } else if (medicalAssistance) {
    treatmentUnitPrice = 0;
  } else if (isSelfPaid) {
    treatmentUnitPrice = 0;
  } else if (Number.isFinite(patientUnitPrice) && patientUnitPrice !== 0) {
    treatmentUnitPrice = patientUnitPrice;
  } else {
    treatmentUnitPrice = BILLING_UNIT_PRICE;
  }

  const hasChargeablePrice = Number.isFinite(treatmentUnitPrice) && treatmentUnitPrice !== 0;
  const treatmentAmountFull = hasChargeablePrice && visitCount > 0 ? treatmentUnitPrice * visitCount : 0;
  const burdenMultiplier = isSelfPaid ? 1 : (Number.isFinite(burdenRate) && burdenRate > 0 ? burdenRate / 10 : 0);
  const treatmentAmount = isSelfPaid
    ? treatmentAmountFull
    : roundToNearestTen(treatmentAmountFull * burdenMultiplier);
  const transportAmount = hasManualTransport
    ? normalizedManualTransport
    : hasChargeablePrice && visitCount > 0
      ? BILLING_TRANSPORT_UNIT_PRICE * visitCount
      : 0;
  const manualSelfPayAmount = normalizeMoneyNumber(source.manualSelfPayAmount);
  const grandTotal = carryOverAmount + treatmentAmount + transportAmount + manualSelfPayAmount;

  return { visitCount, treatmentUnitPrice, treatmentAmount, transportAmount, manualSelfPayAmount, grandTotal };
}

function normalizeServerBillingTotals(result, fallback) {
  const payload = result && typeof result === 'object' ? result : {};
  const base = fallback && typeof fallback === 'object' ? fallback : {};
  return {
    visitCount: Number(payload.visitCount != null ? payload.visitCount : payload.visits) || base.visitCount || 0,
    treatmentUnitPrice: Number(payload.treatmentUnitPrice != null ? payload.treatmentUnitPrice : payload.unitPrice)
      || base.treatmentUnitPrice
      || 0,
    treatmentAmount: Number(payload.treatmentAmount) || base.treatmentAmount || 0,
    transportAmount: Number(payload.transportAmount) || base.transportAmount || 0,
    carryOverAmount: Number(payload.carryOverAmount) || base.carryOverAmount || 0,
    billingAmount: Number(payload.billingAmount) || base.billingAmount || 0,
    manualSelfPayAmount: Number(payload.manualSelfPayAmount) || base.manualSelfPayAmount || 0,
    grandTotal: Number(payload.grandTotal) || base.grandTotal || 0
  };
}

function resetBillingEdits() {
  billingState.edits = {};
  billingState.patientInfoEdits = {};
  billingState.billingOverrideEdits = {};
  billingState.previewTotals = {};
  billingState.editing = null;
}

function getBillingEditTarget(field) {
  if (!field) return null;
  if (BILLING_PATIENT_INFO_FIELDS.indexOf(field) >= 0) return 'patientInfo';
  if (BILLING_BILLING_OVERRIDES_FIELDS.indexOf(field) >= 0) return 'billingOverrides';
  return null;
}

function resolvePatientInfoEditFields(field, value) {
  if (!field) return {};
  if (field === 'bankInfo' && value && typeof value === 'object') {
    return {
      bankCode: value.bankCode,
      branchCode: value.branchCode,
      accountNumber: value.accountNumber
    };
  }
  return { [field]: value };
}

function resolveBillingOverrideFields(field, value) {
  switch (field) {
    case 'unitPrice':
      return { manualUnitPrice: value };
    case 'transportAmount':
      return { manualTransportAmount: value === '' ? '' : value };
    case 'visitCount':
      return { visitCount: value };
    case 'carryOverAmount':
      return { carryOverAmount: value };
    case 'selfPayAmount':
      return { manualSelfPayAmount: value === '' ? '' : value };
    default:
      return {};
  }
}

function recordBillingEditForPersistence(patientId, field, value) {
  const target = getBillingEditTarget(field);
  const pid = String(patientId || '').trim();
  if (!pid || !target) return;

  if (target === 'patientInfo') {
    const current = billingState.patientInfoEdits[pid] || {};
    billingState.patientInfoEdits[pid] = Object.assign({}, current, resolvePatientInfoEditFields(field, value));
    return;
  }

  if (target === 'billingOverrides') {
    const current = billingState.billingOverrideEdits[pid] || {};
    billingState.billingOverrideEdits[pid] = Object.assign({}, current, resolveBillingOverrideFields(field, value));
  }
}

function buildBillingSavePayload() {
  const patientInfoUpdates = Object.keys(billingState.patientInfoEdits || {}).map(pid =>
    Object.assign({ patientId: pid }, billingState.patientInfoEdits[pid])
  );
  const billingOverridesUpdates = Object.keys(billingState.billingOverrideEdits || {}).map(pid =>
    Object.assign({ patientId: pid }, billingState.billingOverrideEdits[pid])
  );
  return { patientInfoUpdates, billingOverridesUpdates };
}

function recalculateBillingRow(patientId) {
  const pid = String(patientId || '').trim();
  if (!pid) return;
  const baseRows = Array.isArray(billingState.result && billingState.result.billingJson)
    ? billingState.result.billingJson
    : [];
  const baseRow = baseRows.find(row => String(row && row.patientId ? row.patientId : '') === pid) || {};
  const edits = billingState.edits[pid] || {};
  const merged = Object.assign({}, baseRow, edits);
  const fallbackTotals = calculateBillingRowTotalsLocal(merged);
  billingState.previewTotals[pid] = fallbackTotals;

  const scriptRun = typeof google !== 'undefined' && google.script && google.script.run;
  if (scriptRun && typeof google.script.run.calculateBillingRowTotalsServer === 'function') {
    google.script.run
      .withSuccessHandler(function(result) {
        billingState.previewTotals[pid] = normalizeServerBillingTotals(result, fallbackTotals);
        renderBillingResult();
      })
      .withFailureHandler(function(err) {
        console.error('Failed to calculate billing totals on server', err);
      })
      .calculateBillingRowTotalsServer(merged);
  }
}

function commitBillingEdit(patientId, field, value) {
  const pid = String(patientId || '').trim();
  if (!pid) return;
  const currentEdits = billingState.edits[pid] || {};
  const baseUpdate = Object.assign({}, currentEdits, { [field]: value });
  if (field === 'unitPrice') {
    baseUpdate.manualUnitPrice = value;
  }
  if (field === 'transportAmount') {
    baseUpdate.manualTransportAmount = value === '' ? '' : value;
  }
  if (field === 'selfPayAmount') {
    baseUpdate.manualSelfPayAmount = value === '' ? '' : value;
  }
  recordBillingEditForPersistence(pid, field, value);
  billingState.edits[pid] = baseUpdate;
  billingState.editing = null;
  recalculateBillingRow(pid);
  renderBillingResult();
}

function startBillingEdit(patientId, field) {
  billingState.editing = { patientId, field };
  renderBillingResult();
}

function ensureBillingRoute() {
  // Routing is managed in-memory to avoid sandboxed URL mutations that raise SecurityError.
  if (typeof window !== 'undefined') {
    window.APP_CONFIG = Object.assign({}, window.APP_CONFIG, { view: 'billing' });
  }
}

function loadBillingPage() {
  initBillingPage();
}

function normalizeBillingResultPayload(raw) {
  if (!raw) return null;

  const BILLING_ROW_DEFAULTS = {
    billingMonth: '',
    patientId: '',
    nameKanji: '',
    nameKana: '',
    address: '',
    insuranceType: '',
    burdenRate: 0,
    medicalAssistance: 0,
    manualUnitPrice: '',
    manualTransportAmount: '',
    manualSelfPayAmount: '',
    selfPayItems: [],
    unitPrice: 0,
    visitCount: 0,
    treatmentAmount: 0,
    transportAmount: 0,
    selfPayTotal: 0,
    carryOverAmount: 0,
    carryOverFromHistory: 0,
    billingAmount: 0,
    total: 0,
    grandTotal: 0,
    responsibleEmail: '',
    responsibleNames: [],
    responsibleName: '',
    payerType: '',
    bankStatus: '',
    paidStatus: '',
    bankCode: '',
    branchCode: '',
    accountNumber: '',
    isNew: 0
  };

  function applyBillingFieldDefaults(payload) {
    if (!payload || typeof payload !== 'object') return payload;
    return Object.assign(
      {
        staffByPatient: {},
        staffDirectory: {},
        staffDisplayByPatient: {},
        patients: {},
        bankInfoByName: {},
        bankStatuses: {},
        carryOverByPatient: {},
        billingOverrideFlags: {}
      },
      payload,
      {
        staffByPatient: payload.staffByPatient || {},
        staffDirectory: payload.staffDirectory || {},
        staffDisplayByPatient: payload.staffDisplayByPatient || {},
        patients: payload.patients || payload.patientMap || {},
        bankInfoByName: payload.bankInfoByName || {},
        bankStatuses: payload.bankStatuses || {},
        carryOverByPatient: payload.carryOverByPatient || {},
        billingOverrideFlags: payload.billingOverrideFlags || {}
      }
    );
  }

  function normalizeManualUnitPriceValue(value) {
    if (value === null || value === undefined || value === '') return '';
    return normalizeMoneyNumber(value);
  }

  function normalizeManualTransportAmountValue(value) {
    if (value === null || value === undefined || value === '') return '';
    return normalizeMoneyNumber(value);
  }

  function normalizeManualSelfPayAmountValue(value) {
    if (value === null || value === undefined || value === '') return '';
    return normalizeMoneyNumber(value);
  }

  function mergePatientMetaIntoRows(rows, patients) {
    if (!Array.isArray(rows)) return [];
    return rows.map(row => {
      const pid = row && row.patientId ? String(row.patientId).trim() : '';
      const patient = pid && patients ? patients[pid] || {} : {};

      const patientSeed = {
        patientId: pid || patient.patientId || '',
        nameKanji: patient.nameKanji,
        nameKana: patient.nameKana,
        address: patient.address,
        insuranceType: patient.insuranceType,
        burdenRate: patient.burdenRate,
        medicalAssistance: patient.medicalAssistance,
        manualUnitPrice: patient.manualUnitPrice != null ? patient.manualUnitPrice : patient.unitPrice,
        manualTransportAmount: patient.manualTransportAmount,
        manualSelfPayAmount: patient.manualSelfPayAmount,
        selfPayItems: patient.selfPayItems,
        unitPrice: patient.unitPrice,
        visitCount: patient.visitCount,
        carryOverAmount: patient.carryOverAmount,
        carryOverFromHistory: patient.carryOverFromHistory,
        payerType: patient.payerType,
        responsibleEmail: patient.responsibleEmail,
        responsibleNames: patient.responsibleNames,
        responsibleName: patient.responsibleName,
        bankStatus: patient.bankStatus,
        paidStatus: patient.paidStatus,
        bankCode: patient.bankCode,
        branchCode: patient.branchCode,
        accountNumber: patient.accountNumber,
        isNew: patient.isNew
      };

      const merged = Object.assign({}, BILLING_ROW_DEFAULTS, patientSeed, row || {});

      const burdenSource = row && row.hasOwnProperty('burdenRate') ? row.burdenRate : patient.burdenRate;
      merged.burdenRate = burdenSource === '自費' ? '自費' : normalizeBurdenRateInt(burdenSource);

      const assistanceSource = row && row.hasOwnProperty('medicalAssistance')
        ? row.medicalAssistance
        : patient.medicalAssistance;
      merged.medicalAssistance = normalizeMedicalAssistanceFlag(assistanceSource);

      const manualPriceSource = row && row.hasOwnProperty('manualUnitPrice')
        ? row.manualUnitPrice
        : patientSeed.manualUnitPrice;
      merged.manualUnitPrice = normalizeManualUnitPriceValue(manualPriceSource);

      const manualTransportSource = row && row.hasOwnProperty('manualTransportAmount')
        ? row.manualTransportAmount
        : patientSeed.manualTransportAmount;
      merged.manualTransportAmount = normalizeManualTransportAmountValue(manualTransportSource);

      const manualSelfPaySource = row && row.hasOwnProperty('manualSelfPayAmount')
        ? row.manualSelfPayAmount
        : patientSeed.manualSelfPayAmount;
      merged.manualSelfPayAmount = normalizeManualSelfPayAmountValue(manualSelfPaySource);
      merged.selfPayItems = Array.isArray(row && row.selfPayItems)
        ? row.selfPayItems
        : Array.isArray(patientSeed.selfPayItems) ? patientSeed.selfPayItems : [];

      merged.insuranceType = (row && row.insuranceType) || patient.insuranceType || '';
      merged.responsibleNames = Array.isArray(merged.responsibleNames) ? merged.responsibleNames : [];
      merged.bankCode = merged.bankCode || '';
      merged.branchCode = merged.branchCode || '';
      merged.accountNumber = merged.accountNumber || '';
      merged.isNew = merged.isNew === 1 || merged.isNew === '1' || merged.isNew === true ? 1 : 0;

      return merged;
    });
  }

  function normalizeBillingPayload(payload) {
    const withDefaults = applyBillingFieldDefaults(payload);
    const billingJson = coerceBillingJson(withDefaults.billingJson) || [];
    const fallbackBillingMonth = billingJson && billingJson.length ? billingJson[0].billingMonth : '';
    const resolvedBillingMonth =
      withDefaults.billingMonth ||
      (withDefaults.month && withDefaults.month.key) ||
      fallbackBillingMonth ||
      '';
    const enrichedRows = mergePatientMetaIntoRows(billingJson, withDefaults.patients || {});
    return Object.assign({}, withDefaults, { billingMonth: resolvedBillingMonth, billingJson: enrichedRows });
  }

  function parseMaybeJson(value) {
    if (typeof value !== 'string') return value;
    try {
      return JSON.parse(value);
    } catch (err) {
      const msg = err && err.message ? err.message : err;
      console.warn('Failed to parse billing payload text:', msg);
      return null;
    }
  }

  function coerceBillingJson(value) {
    if (Array.isArray(value)) return value;
    if (typeof value === 'string') {
      try {
        const parsed = JSON.parse(value);
        return Array.isArray(parsed) ? parsed : null;
      } catch (err) {
        const msg = err && err.message ? err.message : err;
        console.warn('Failed to parse billingJson string:', msg);
        return null;
      }
    }
    return null;
  }

  function findBillingPayload(root, metaSource) {
    const queue = [];
    const visited = new WeakSet();

    const OBJECT_META_FIELDS = [
      'staffByPatient',
      'staffDirectory',
      'staffDisplayByPatient',
      'patients',
      'patientMap',
      'bankInfoByName',
      'bankStatuses',
      'carryOverByPatient'
    ];
    const ARRAY_META_FIELDS = ['files'];

    function extractMetaFields(source) {
      if (!source || typeof source !== 'object') return {};
      const meta = {};
      Object.keys(source).forEach(key => {
        const value = source[key];
        const type = typeof value;
        const isDate = Object.prototype.toString.call(value) === '[object Date]';
        const isPlainObject = value && !Array.isArray(value) && !isDate && type === 'object';
        if (OBJECT_META_FIELDS.includes(key) && isPlainObject) {
          meta[key] = value;
        } else if (ARRAY_META_FIELDS.includes(key) && Array.isArray(value)) {
          meta[key] = value;
        } else if (value === null || type === 'string' || type === 'number' || type === 'boolean' || isDate) {
          meta[key] = value;
        }
      });

      ['meta', 'metadata'].forEach(nestedKey => {
        const nested = source[nestedKey];
        if (nested && typeof nested === 'object') {
          Object.assign(meta, extractMetaFields(nested));
        }
      });
      return meta;
    }

    function mergeWithMeta(obj, meta) {
      const billingJson = coerceBillingJson(obj.billingJson);
      if (!billingJson) return null;
      return normalizeBillingPayload(Object.assign({}, meta, obj, { billingJson }));
    }

    function enqueue(candidate, inheritedMeta) {
      const parsed = parseMaybeJson(candidate);
      const value = parsed === null ? candidate : parsed;
      if (value && typeof value === 'object' && !visited.has(value)) {
        visited.add(value);
        const meta = Object.assign({}, inheritedMeta, extractMetaFields(value));
        queue.push({ obj: value, meta });
      }
    }

    const initialMeta = extractMetaFields(metaSource);
    enqueue(root, initialMeta);

    while (queue.length) {
      const { obj, meta } = queue.shift();
      const merged = mergeWithMeta(obj, meta);
      if (merged) {
        return merged;
      }

      Object.keys(obj).forEach(key => {
        const value = obj[key];
        enqueue(value, meta);
      });
    }

    return null;
  }

  let result = parseMaybeJson(raw);
  if (result == null) return null;

  if (Array.isArray(result)) {
    return normalizeBillingPayload({ billingJson: result, billingMonth: '', preparedAt: null });
  }

  const found = findBillingPayload(result, result);
  if (found && found.billingJson) {
    return normalizeBillingPayload(found);
  }

  const billingJson = coerceBillingJson(result.billingJson) || [];
  if (!billingJson.length) {
    console.warn('[billing] billingJson not found in payload; returning empty array');
  }
  return normalizeBillingPayload(Object.assign({}, result, { billingJson }));
}

function handleBillingAggregation() {
  const ym = normalizeYm(qs('billingMonth').value);
  if (!ym) {
    alert('請求月を入力してください (YYYY-MM)');
    return;
  }
  logBillingState('handleBillingAggregation:start', { ym });
  setBillingLoading(true, '集計中…');
  google.script.run
    .withSuccessHandler(function(result) {
      logBillingState('prepareBillingData:success', { ym });
      onBillingPrepared(result);
    })
    .withFailureHandler(function(err) {
      logBillingState('prepareBillingData:error', { ym, error: err && err.message ? err.message : err });
      onBillingFailed(err);
    })
    .prepareBillingData(ym);
}

function onBillingPrepared(result) {
  console.warn('[billing-debug] raw result = ', JSON.stringify(result, null, 2).slice(0, 5000));
  try {
    const normalized = normalizeBillingResultPayload(result);
    billingState.result = normalized;
    billingState.prepared = normalized;
    billingState.loading = false;
    billingState.statusMessage = '集計が完了しました。内容確認後にPDFを生成してください。';
    billingState.errorMessage = '';
    resetBillingEdits();
    logBillingState('onBillingPrepared', { rows: normalized && normalized.billingJson ? normalized.billingJson.length : 0 });
    renderBillingResult();
  } catch (err) {
    billingState.loading = false;
    billingState.statusMessage = '集計データの処理に失敗しました';
    setBillingError('集計結果の整形中にエラーが発生しました', err);
  }
}

function handleBillingPdfGeneration() {
  if (!billingState.prepared || !billingState.prepared.billingMonth) {
    alert('先に「請求データを集計」を実行してください。');
    return;
  }
  setBillingLoading(true, 'PDF生成中…');
  google.script.run
    .withSuccessHandler(onBillingPdfCompleted)
    .withFailureHandler(onBillingFailed)
    .applyBillingEditsAndGenerateInvoices(billingState.prepared.billingMonth, buildBillingSavePayload());
}

function onBillingPdfCompleted(result) {
  try {
    const normalized = normalizeBillingResultPayload(result) || billingState.prepared || null;
    billingState.result = normalized;
    billingState.prepared = normalized;
    billingState.loading = false;
    billingState.statusMessage = 'PDF生成と担当者フォルダへの保存が完了しました';
    billingState.errorMessage = '';
    resetBillingEdits();
    logBillingState('onBillingPdfCompleted', { rows: normalized && normalized.billingJson ? normalized.billingJson.length : 0 });
    renderBillingResult();
  } catch (err) {
    billingState.loading = false;
    billingState.statusMessage = 'PDF生成結果の処理に失敗しました';
    setBillingError('PDF生成後の結果処理でエラーが発生しました', err);
  }
}

function handleBankExport() {
  if (!billingState.prepared || !billingState.prepared.billingMonth) {
    alert('先に「請求データを集計」を実行してください。');
    return;
  }
  setBillingLoading(true, '銀行データ出力中…');
  google.script.run
    .withSuccessHandler(onBankExportCompleted)
    .withFailureHandler(onBillingFailed)
    .generateBankTransferDataFromCache(billingState.prepared.billingMonth, {
      billingMonth: billingState.prepared.billingMonth
    });
}

function onBankExportCompleted(result) {
  billingState.loading = false;
  if (result && result.message) {
    billingState.statusMessage = result.message;
  } else {
    billingState.statusMessage = '銀行データを出力しました' + (result && result.inserted ? `（${result.inserted}件）` : '');
  }
  billingState.errorMessage = '';
  logBillingState('onBankExportCompleted');
  renderBillingResult();
}

function handleBillingSaveEdits() {
  if (!billingState.prepared || !billingState.prepared.billingMonth) {
    alert('先に「請求データを集計」を実行してください。');
    return;
  }
  setBillingLoading(true, '保存中…');
  google.script.run
    .withSuccessHandler(onBillingSaveCompleted)
    .withFailureHandler(onBillingFailed)
    .applyBillingEdits(billingState.prepared.billingMonth, buildBillingSavePayload());
}

function onBillingSaveCompleted(result) {
  const nextResult = result || billingState.result || null;
  if (nextResult) {
    billingState.result = nextResult;
    billingState.prepared = nextResult;
  }
  billingState.loading = false;
  billingState.statusMessage = '保存が完了しました';
  billingState.errorMessage = '';
  resetBillingEdits();
  const rowCount = billingState.prepared && billingState.prepared.billingJson
    ? billingState.prepared.billingJson.length
    : 0;
  logBillingState('onBillingSaveCompleted', { rows: rowCount });
  renderBillingResult();
}

function onBillingFailed(err) {
  console.error('[billing generation failed]', err);
  const msg = err && err.message ? err.message : String(err);
  billingState.loading = false;
  billingState.statusMessage = '請求処理に失敗しました';
  setBillingError('請求処理でエラーが発生しました', msg);
  alert('請求生成に失敗しました: ' + msg);
}

function formatCurrency(value) {
  const num = Number(value);
  if (!Number.isFinite(num)) return '-';
  return num.toLocaleString('ja-JP') + ' 円';
}

function renderBillingStatus(result) {
  const el = qs('billingStatus');
  if (!el) return;
  if (billingState.errorMessage) {
    el.textContent = '';
    return;
  }
  if (billingState.loading) {
    el.innerHTML = `<span class="loading"><span class="spinner"></span>${billingState.statusMessage || '生成中…'}</span>`;
    return;
  }
  if (billingState.statusMessage) {
    el.textContent = billingState.statusMessage;
    return;
  }
  if (billingState.prepared) {
    el.textContent = result && result.files && result.files.length
      ? 'PDF生成が完了しました'
      : '集計済み（PDF未生成）';
    return;
  }
  el.textContent = '';
}

function renderCarryOverLedgerStatus() {
  const badge = qs('carryOverLedgerStatus');
  if (!badge) return;
  const meta = billingState.prepared && billingState.prepared.carryOverLedgerMeta
    ? billingState.prepared.carryOverLedgerMeta
    : null;
  const hasMeta = meta && Object.keys(meta).length > 0;
  if (!billingState.prepared || !hasMeta) {
    badge.style.display = 'none';
    badge.textContent = '';
    badge.removeAttribute('title');
    return;
  }
  const loadError = meta.loadError;
  const wasAutoCreated = !!meta.wasAutoCreated;
  const headerInserted = !!meta.headerInserted;
  const dataRowCount = Number(meta.dataRowCount || 0);
  const wasInitialized = wasAutoCreated || headerInserted;

  if (loadError) {
    badge.className = 'pill warn';
    badge.textContent = 'Ledger 読み込みエラー';
    badge.title = loadError;
    badge.style.display = 'inline-flex';
    return;
  }
  if (wasInitialized) {
    badge.className = 'pill warn';
    badge.textContent = 'Ledger 未作成 → 自動初期化';
    badge.title = 'CarryOverLedger シートが見つからなかったため、自動で作成または初期化しました。';
    badge.style.display = 'inline-flex';
    return;
  }

  badge.className = dataRowCount > 0 ? 'pill ok' : 'pill neutral';
  badge.textContent = dataRowCount > 0 ? `Ledger OK（${dataRowCount}件）` : 'Ledger 0件（作成済み）';
  badge.title = dataRowCount > 0
    ? 'CarryOverLedger の読み込みに成功しました'
    : 'CarryOverLedger は空ですが作成済みです';
  badge.style.display = 'inline-flex';
}

function renderBillingError() {
  const box = qs('billingError');
  if (!box) return;
  const msg = billingState.errorMessage;
  if (msg) {
    box.style.display = '';
    box.innerHTML = `<strong>請求処理中にエラーが発生しました。</strong><div>${escapeHtml(msg)}</div>`;
    return;
  }
  box.style.display = 'none';
  box.textContent = '';
}

function renderDownloads(result) {
  const box = qs('downloads');
  if (!box) return;
  box.innerHTML = '';
  if (billingState.loading) {
    box.innerHTML = `<div class="loading"><span class="spinner"></span>ファイル生成中…</div>`;
    return;
  }
  const files = (result && Array.isArray(result.files)) ? result.files.filter(file => file && file.url) : [];
  if (!files.length) {
    box.innerHTML = billingState.prepared
      ? '<div class="muted">集計済みです。PDF生成ボタンを押してください。</div>'
      : '<div class="muted">出力ファイルはまだありません。</div>';
    return;
  }
  box.innerHTML = files.map(link => `
    <a class="download-link" href="${link.url}" target="_blank" rel="noopener">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <path d="M12 3v14" /><path d="M5 10l7 7 7-7" /><path d="M5 21h14" />
      </svg>
      <div>
        <div>${link.name || '請求書PDF'}</div>
        <small class="muted" style="display:block;">${link.nameKanji || link.patientId || ''}</small>
      </div>
    </a>`).join('');
}

function renderMonthBadge(result) {
  const label = qs('billingMonthLabel');
  if (!label) return;
  if (result && result.billingMonth) {
    label.style.display = 'inline-flex';
    label.textContent = '請求月: ' + result.billingMonth;
  } else {
    label.style.display = 'none';
    label.textContent = '';
  }
}

function renderBillingSummary(rows) {
  const box = qs('billingSummary');
  if (!box) return;
  if (!rows || !rows.length) {
    box.style.display = 'none';
    box.innerHTML = '';
    return;
  }
  const summary = calculateBillingSummary(rows);
  box.style.display = '';
  box.innerHTML = `
    <div class="summary-card">
      <p class="summary-label">総施術回数</p>
      <p class="summary-value">${summary.totalVisits.toLocaleString()} 回</p>
    </div>
    <div class="summary-card">
      <p class="summary-label">請求合計金額</p>
      <p class="summary-value">${formatCurrency(summary.totalGrandTotal)}</p>
    </div>
  `;
}

function renderBillingResult() {
  logBillingState('renderBillingResult', {
    resultLength: billingState.result && billingState.result.billingJson ? billingState.result.billingJson.length : 0,
    preparedLength: billingState.prepared && billingState.prepared.billingJson ? billingState.prepared.billingJson.length : 0
  });
  updateBillingControls();
  const box = qs('billingResult');
  if (!box) return;
  const result = billingState.result;
    renderBillingError();
    renderBillingStatus(result);
    renderCarryOverLedgerStatus();
    renderDownloads(result);
    renderMonthBadge(result);
    renderBillingSummary(null);

  if (billingState.loading) {
    box.innerHTML = '<div class="loading"><span class="spinner"></span>請求データを生成中です…</div>';
    return;
  }
  if (billingState.errorMessage) {
    box.innerHTML = '<div class="alert danger">請求処理中にエラーが発生しました。詳細は上部のエラーメッセージをご確認ください。</div>';
    return;
  }
  if (!result || !result.billingJson || !result.billingJson.length) {
    renderBillingSummary(null);
    box.innerHTML = '<div class="muted">まだ請求を生成していません。</div>';
    return;
  }

  const rows = getDisplayBillingRows();
  renderBillingSummary(rows);
  const header = [
    { key: 'patientId', label: '患者ID', sortable: true },
    { key: 'nameKanji', label: '氏名', sortable: true },
    { key: 'responsible', label: '担当者', sortable: true },
    { key: 'medicalAssistance', label: '医療助成', sortable: false },
    { key: 'payerType', label: '保険者', sortable: false },
    { key: 'burdenRate', label: '負担', sortable: true },
    { key: 'visitCount', label: '回数', sortable: true },
    { key: 'unitPrice', label: '単価', sortable: true },
    { key: 'treatmentAmount', label: '施術料', sortable: true },
    { key: 'transportAmount', label: '交通費', sortable: true },
    { key: 'carryOverAmount', label: '繰越', sortable: true },
    { key: 'grandTotal', label: '合計', sortable: true },
    { key: 'paidStatus', label: '領収状態', sortable: false },
    { key: 'bankInfo', label: '口座情報', sortable: false },
    { key: 'isNew', label: '新規', sortable: false }
  ];

  const columnCount = header.length;

  function renderSortHeaderCell(h) {
    if (!h.sortable) {
      return `<th>${h.label}</th>`;
    }
    const active = billingState.sort && billingState.sort.field === h.key;
    const indicator = active ? (billingState.sort.direction === 'asc' ? '▲' : '▼') : '';
    const thClass = h.sortable ? 'sortable' : '';
    return `<th class="${thClass}"><button type="button" class="sort-header" data-sort-key="${h.key}">${h.label}${indicator ? `<span class="sort-indicator">${indicator}</span>` : ''}</button></th>`;
  }

  function renderEditableCell(item, field, alignRight) {
    const editing = billingState.editing && billingState.editing.patientId === item.patientId && billingState.editing.field === field;
    const baseAttrs = `data-edit-field="${field}" data-edit-patient="${item.patientId}"`;
    const editClass = alignRight ? 'cell-edit inline-editor right' : 'cell-edit inline-editor';
    const viewClass = alignRight ? 'cell-edit right' : 'cell-edit';
    if (editing) {
      if (field === 'burdenRate') {
        const editor = `<select class="${editClass}" ${baseAttrs}>${BILLING_BURDEN_OPTIONS.map(opt => `<option value="${opt.value}" ${String(opt.value) === String(item.burdenRate) ? 'selected' : ''}>${opt.label}</option>`).join('')}</select>`;
        const showSelfPay = String(item.burdenRate) === '自費' || String(item.insuranceType).trim() === '自費';
        const selfPayValue = item.manualSelfPayAmount === '' || item.manualSelfPayAmount === null || item.manualSelfPayAmount === undefined
          ? ''
          : normalizeEditNumber(item.manualSelfPayAmount);
        const selfPayAttrs = `data-edit-field="selfPayAmount" data-edit-patient="${item.patientId}"`;
        const selfPayEditor = showSelfPay
          ? wrapWithOverrideBadge(
            `<div class="selfpay-editor"><label>自費金額<input class="${editClass}" ${selfPayAttrs} type="number" step="10" value="${selfPayValue}" /></label></div>`,
            item.patientId,
            'selfPayAmount',
            alignRight
          )
          : '';
        return wrapWithOverrideBadge(`<div class="burden-editor">${editor}${selfPayEditor}</div>`, item.patientId, field, alignRight);
      }
      if (field === 'payerType') {
        const editor = `<select class="${editClass}" ${baseAttrs}>${BILLING_PAYER_OPTIONS.map(opt => `<option value="${opt}" ${opt === item.payerType ? 'selected' : ''}>${opt}</option>`).join('')}</select>`;
        return wrapWithOverrideBadge(editor, item.patientId, field, alignRight);
      }
      if (field === 'medicalAssistance') {
        const checked = normalizeMedicalAssistanceFlag(item.medicalAssistance) ? 'checked' : '';
        const editor = `<label class="${editClass}" style="display:flex;align-items:center;gap:6px;"><input type="checkbox" ${baseAttrs} ${checked} />医療助成</label>`;
        return wrapWithOverrideBadge(editor, item.patientId, field, alignRight);
      }
      if (field === 'unitPrice' || field === 'carryOverAmount') {
        const val = normalizeEditNumber(item[field]);
        const editor = `<input class="${editClass}" ${baseAttrs} type="number" step="10" value="${val}" />`;
        return wrapWithOverrideBadge(editor, item.patientId, field, alignRight);
      }
      if (field === 'transportAmount') {
        const val = item.manualTransportAmount === '' || item.manualTransportAmount === null || item.manualTransportAmount === undefined
          ? ''
          : normalizeEditNumber(item.manualTransportAmount);
        const placeholder = Number.isFinite(item.transportAmount) ? formatCurrency(item.transportAmount) : '';
        const editor = `<input class="${editClass}" ${baseAttrs} type="number" step="10" value="${val}" placeholder="${placeholder}" />`;
        return wrapWithOverrideBadge(editor, item.patientId, field, alignRight);
      }
    }

    const display = (() => {
      switch (field) {
        case 'medicalAssistance':
          return normalizeMedicalAssistanceFlag(item.medicalAssistance) ? '有' : 'なし';
        case 'burdenRate':
          if (String(item.burdenRate) === '自費') {
            const selfPayAmount = item.manualSelfPayAmount || 0;
            const label = normalizeBurdenRateDisplay(item.burdenRate) || '自費';
            return selfPayAmount ? `${label}（${formatCurrency(selfPayAmount)}円）` : label;
          }
          return normalizeBurdenRateDisplay(item.burdenRate) || '編集';
        case 'payerType':
          return item.payerType || '編集';
        case 'unitPrice':
          return formatCurrency(item.unitPrice);
        case 'transportAmount':
          return formatCurrency(item.transportAmount);
        case 'carryOverAmount':
          return formatCurrency(item.carryOverAmount);
        default:
          return item[field] || '';
      }
    })();
    const view = `<button type="button" class="${viewClass}" ${baseAttrs} aria-label="${field} を編集">${display}</button>`;
    return wrapWithOverrideBadge(view, item.patientId, field, alignRight);
  }

  const bodyRows = [];
  rows.forEach(item => {
    try {
      const safeItem = item && typeof item === 'object' ? item : {};
      bodyRows.push(`
      <tr>
        <td>${safeItem.patientId || ''}</td>
        <td>${safeItem.nameKanji || ''}</td>
        <td>${getResponsibleDisplay(safeItem) || '—'}</td>
        <td>${renderEditableCell(safeItem, 'medicalAssistance')}</td>
        <td>${renderEditableCell(safeItem, 'payerType')}</td>
        <td>${renderEditableCell(safeItem, 'burdenRate')}</td>
        <td>${wrapWithOverrideBadge(safeItem.visitCount || 0, safeItem.patientId, 'visitCount')}</td>
        <td class="right">${renderEditableCell(safeItem, 'unitPrice', true)}</td>
        <td class="right">${formatCurrency(safeItem.treatmentAmount)}</td>
        <td class="right">${renderEditableCell(safeItem, 'transportAmount', true)}</td>
        <td class="right">${renderEditableCell(safeItem, 'carryOverAmount', true)}</td>
        <td class="right">${formatCurrency(safeItem.grandTotal)}</td>
        <td>${formatPaidStatus(safeItem) || '—'}</td>
        <td>${formatBankInfo(safeItem) || '—'}</td>
        <td>${formatNewFlag(safeItem) || ''}</td>
      </tr>`);
    } catch (err) {
      console.error('Failed to render billing row', err, item);
      const pid = item && item.patientId ? `患者ID: ${item.patientId}` : '患者行の表示でエラーが発生しました';
      bodyRows.push(`<tr class="error-row"><td colspan="${columnCount}">${pid}</td></tr>`);
    }
  });

  const tableHtml = [
    '<table><thead><tr>',
    header.map(renderSortHeaderCell).join(''),
    '</tr></thead><tbody>',
    ...bodyRows,
    '</tbody></table>',
    renderBillingActionFooter(rows && rows.length > 0)
  ].join('');

  box.innerHTML = tableHtml;
  attachBillingEditHandlers();
  attachBillingSortHandlers();
}

function renderBillingActionFooter(hasRows) {
  if (!hasRows) return '';
  const prepared = !!(billingState.prepared && billingState.prepared.billingMonth);
  const loading = billingState.loading;
  const saveDisabled = loading || !prepared;
  const pdfDisabled = loading || !prepared;
  const helper = prepared
    ? '編集を保存したら、そのままPDF生成へ進めます。'
    : '先に「請求データを集計」を実行すると保存・PDF生成が有効になります。';
  return `
    <div class="action-footer">
      <div>
        <div class="muted">${helper}</div>
      </div>
      <div class="action-buttons">
        <button class="btn secondary" type="button" onclick="handleBillingSaveEdits()" ${saveDisabled ? 'disabled' : ''}>変更を保存</button>
        <button class="btn" type="button" onclick="handleBillingPdfGeneration()" ${pdfDisabled ? 'disabled' : ''}>PDF生成＆担当者フォルダ保存</button>
      </div>
    </div>`;
}

function attachBillingEditHandlers() {
  const box = qs('billingResult');
  if (!box) return;
  box.querySelectorAll('button.cell-edit').forEach(btn => {
    btn.onclick = function () {
      const pid = this.getAttribute('data-edit-patient');
      const field = this.getAttribute('data-edit-field');
      startBillingEdit(pid, field);
    };
  });
  box.querySelectorAll('select.inline-editor, input.inline-editor').forEach(input => {
    input.onchange = function () {
      const pid = this.getAttribute('data-edit-patient');
      const field = this.getAttribute('data-edit-field');
      let value = this.value;
      if (this.type === 'checkbox') {
        value = normalizeMedicalAssistanceFlag(this.checked);
      }
      if (field === 'burdenRate') {
        value = value === '自費' ? '自費' : normalizeBurdenRateInt(value);
      }
      if (field === 'unitPrice' || field === 'carryOverAmount') {
        value = normalizeMoneyNumber(value);
      }
      if (field === 'transportAmount') {
        value = value === '' ? '' : normalizeMoneyNumber(value);
      }
      if (field === 'selfPayAmount') {
        value = value === '' ? '' : normalizeMoneyNumber(value);
      }
      if (field === 'visitCount') {
        value = normalizeVisitCount(value);
      }
      commitBillingEdit(pid, field, value);
    };
    input.onblur = input.onchange;
  });
}

function attachBillingSortHandlers() {
  const box = qs('billingResult');
  if (!box) return;
  box.querySelectorAll('button.sort-header').forEach(btn => {
    btn.onclick = function () {
      const field = this.getAttribute('data-sort-key');
      toggleBillingSort(field);
    };
  });
}

function initBillingPage() {
  ensureBillingRoute();
  const input = qs('billingMonth');
  if (input && !input.value) {
    input.value = getDefaultMonth();
  }
  updateBillingControls();
  renderBillingResult();
}

(function bootstrap() {
  const body = document.body;
  if (body && body.dataset) {
    window.APP_CONFIG = Object.assign({}, window.APP_CONFIG, {
      view: body.dataset.view || (window.APP_CONFIG && window.APP_CONFIG.view) || '',
      baseUrl: body.dataset.baseUrl || (window.APP_CONFIG && window.APP_CONFIG.baseUrl) || ''
    });
  }

  const view = (window.APP_CONFIG && window.APP_CONFIG.view) || '';
  if (view === 'billing') {
    initBillingPage();
  }
})();

const billingGlobal = typeof window !== 'undefined' ? window : null;
if (billingGlobal) {
  billingGlobal.loadBillingPage = loadBillingPage;
  billingGlobal.handleBillingAggregation = handleBillingAggregation;
  billingGlobal.handleBillingPdfGeneration = handleBillingPdfGeneration;
  billingGlobal.handleBillingSaveEdits = handleBillingSaveEdits;
  billingGlobal.handleBankExport = handleBankExport;
}
</script>
